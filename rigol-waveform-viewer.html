<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rigol WFM Waveform Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; }
        html, body { height: 100%; overflow: hidden; }
        body { background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); color: #ffffff; padding: 12px; display: flex; flex-direction: column; font-size: 14px; }
        .main-container { flex: 1; display: flex; gap: 20px; background: #2d2d2d; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4); min-height: 0; }
        .sidebar { width: 340px; background: #3c3c3c; padding: 20px; display: flex; flex-direction: column; gap: 24px; overflow-y: auto; transition: width 0.3s ease; }
        .content-area { flex: 1; display: flex; flex-direction: column; background: #252525; min-width: 0; }
        
        /* --- TAB STYLES --- */
        .tab-container { display: flex; background: #252525; flex-shrink: 0; border-bottom: 1px solid #4a4a4a; }
        .tab-item { padding: 10px 15px; cursor: pointer; background: #3c3c3c; color: #ccc; border-right: 1px solid #252525; display: flex; align-items: center; gap: 8px; max-width: 200px; }
        .tab-item:hover { background: #4a4a4a; }
        .tab-item.active { background: #0078d7; color: white; font-weight: 500; }
        .tab-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .tab-close { margin-left: auto; width: 18px; height: 18px; line-height: 18px; text-align: center; border-radius: 50%; }
        .tab-close:hover { background-color: rgba(255,255,255,0.2); }
        .tab-item.active .tab-close:hover { background-color: rgba(0,0,0,0.2); }

        .toolbar { height: 48px; background: #3c3c3c; display: flex; align-items: center; padding: 0 16px; gap: 16px; border-bottom: 1px solid #4a4a4a; flex-shrink: 0; }
        .tool-button { padding: 8px 16px; background: #5e5e5e; border: none; border-radius: 4px; color: white; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 15px; transition: background 0.2s; }
        .tool-button:hover { background: #6a6a6a; }
        .tool-button:active { transform: translateY(1px); }
        .tool-button.active { background: #0078d7; }
        .display-area { flex: 1; position: relative; min-height: 0; }
        .waveform-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1e1e1e; border-radius: 4px; overflow: hidden; cursor: crosshair; }
        canvas { width: 100%; height: 100%; display: block; }
        .status-bar { height: 28px; background: #0078d7; display: flex; align-items: center; justify-content: space-between; padding: 0 16px; font-size: 14px; flex-shrink: 0; margin-top: 12px; }
        .window-title { font-size: 13px; font-weight: 500; color: #cccccc; margin-right: 20px; }
        .panel-title { font-size: 15px; font-weight: 600; margin-bottom: 16px; color: #cccccc; border-bottom: 1px solid #555; padding-bottom: 8px; }
        .file-panel, .control-panel { background: #383838; border-radius: 6px; padding: 16px; }
        .file-info { background: #454545; padding: 12px; border-radius: 4px; margin-top: 12px; font-size: 14px; word-wrap: break-word;}
        .control-item { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .control-label { font-size: 14px; color: #a0a0a0; }
        .control-input { width: 110px; padding: 4px 8px; background: #454545; border: 1px solid #5a5a5a; border-radius: 4px; color: white; pointer-events: none; font-size: 13px; font-family: Consolas, monospace;}
        .checkbox-item { margin-top: 15px; font-size: 14px; display: flex; align-items: center; gap: 8px; }
        .channel-button { display: flex; align-items: center; justify-content: space-between; padding: 9px 12px; background: #454545; border: none; border-radius: 4px; color: white; cursor: pointer; margin-bottom: 8px; width: 100%; transition: background 0.2s; font-size: 15px; }
        .channel-button.active[data-channel="channel1"] { background: #00bcf2; }
        .channel-button.active[data-channel="channel2"] { background: #ff4343; }
        .channel-button .ch-name { display: flex; align-items: center; gap: 8px; }
        .channel-button .ch-order { font-size: 12px; color: #ccc; }
        .file-input { display: none; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 100; display: none; align-items: center; justify-content: center; }
        .modal-content { background: #3c3c3c; padding: 30px; border-radius: 8px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); width: 90%; max-width: 500px; position: relative; border-top: 3px solid #0078d7; }
        .modal-close { position: absolute; top: 10px; right: 15px; font-size: 28px; color: #aaa; cursor: pointer; line-height: 1; }
        .modal-close:hover { color: white; }
        .modal-content h2 { margin-bottom: 20px; font-size: 20px; }
        .shortcut-list { list-style: none; padding-left: 0; }
        .shortcut-list li { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #555; }
        .shortcut-list code { background: #2d2d2d; padding: 3px 7px; border-radius: 4px; font-family: Consolas, monospace; }
        .ieee-options { background: #4a4a4a; padding: 15px; border-radius: 5px; margin-top: 10px; display: none; }
        #ieeeStyleCheckbox:checked ~ .ieee-options { display: block; }
        .modal-footer { margin-top: 30px; text-align: right; }
        .modal-button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 15px; }
        .export-confirm-btn { background: #0078d7; color: white; }
        .export-confirm-btn:hover { background: #005a9e; }
        .sub-panel { margin-top: 12px; border-top: 1px solid #555; padding-top: 12px; }
        #text-annotation-input { position: absolute; background: #2d2d2d; color: white; border: 1px solid #0078d7; padding: 5px; z-index: 110; border-radius: 3px; }
        
        /* --- DRAG & DROP OVERLAY --- */
        #drag-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 120, 215, 0.7); z-index: 200; display: none; align-items: center; justify-content: center; pointer-events: none; }
        .drag-overlay-content { text-align: center; color: white; }
        .drag-overlay-content i { font-size: 80px; }
        .drag-overlay-content span { display: block; font-size: 24px; margin-top: 20px; }

        @media (max-width: 768px) {
            body { padding: 0; }
            .main-container { flex-direction: column; height: 100%; border-radius: 0; gap: 0; }
            .sidebar { width: 100%; border-bottom: 1px solid #4a4a4a; flex-shrink: 0; height: auto; max-height: 45vh; }
            .content-area { min-height: 55vh; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <div class="file-panel">
                <div class="panel-title">File Operations</div>
                <button class="tool-button" id="loadBtn" style="width: 100%"><i class="fas fa-folder-open"></i> Load WFM File</button>
                <input type="file" id="fileInput" class="file-input" accept=".wfm" multiple>
                <button class="tool-button" id="exportBtn" style="width: 100%; margin-top: 12px"><i class="fas fa-save"></i> Export...</button>
                <div class="file-info" id="fileInfo"><div style="margin-bottom: 8px">Drop a file or click Load</div><div>Points: -</div></div>
            </div>
             <div class="control-panel">
                <div class="panel-title">Channel Display</div>
                <button class="channel-button active" data-channel="channel1"><span class="ch-name"><i class="fas fa-wave-square" style="color: #00bcf2"></i> Channel 1</span><span class="ch-order">(Back)</span></button>
                <button class="channel-button active" data-channel="channel2"><span class="ch-name"><i class="fas fa-wave-square" style="color: #ff4343"></i> Channel 2</span><span class="ch-order">(Front)</span></button>
                <button class="tool-button" id="swapOrderBtn" style="width:100%; margin-top: 8px;"><i class="fas fa-layer-group"></i> Swap Order</button>
                <div class="sub-panel">
                    <div class="control-item">
                        <label for="ch1NameInput" class="control-label">Ch 1 Legend</label>
                        <input type="text" id="ch1NameInput" value="Channel 1" class="control-input" style="width: 120px; pointer-events: auto; font-family: 'Segoe UI', sans-serif;">
                    </div>
                    <div class="control-item">
                        <label for="ch2NameInput" class="control-label">Ch 2 Legend</label>
                        <input type="text" id="ch2NameInput" value="Channel 2" class="control-input" style="width: 120px; pointer-events: auto; font-family: 'Segoe UI', sans-serif;">
                    </div>
                </div>
            </div>
            <div class="control-panel">
                <div class="panel-title">Display Controls</div>
                <div class="control-item"><span class="control-label">Time Scale (s/div)</span><input type="text" class="control-input" id="timeScale" value="-" readonly></div>
                <div class="control-item"><span class="control-label">Voltage Scale (V/div)</span><input type="text" class="control-input" id="voltageScale" value="-" readonly></div>
                <div class="checkbox-item">
                    <label for="showStatsCheckbox"><input type="checkbox" id="showStatsCheckbox" checked> Show Measurements</label>
                </div>
                <div id="measurement-controls" class="sub-panel" style="margin-top: 5px; padding-top: 5px;">
                    <div style="display: flex; justify-content: space-around; font-size: 13px; flex-wrap: wrap; gap: 10px;">
                        <label><input type="checkbox" class="meas-toggle" id="showMaxCheckbox" checked> Max</label>
                        <label><input type="checkbox" class="meas-toggle" id="showMinCheckbox" checked> Min</label>
                        <label><input type="checkbox" class="meas-toggle" id="showAvgCheckbox" checked> Avg</label>
                        <label><input type="checkbox" class="meas-toggle" id="showRmsCheckbox" checked> RMS</label>
                    </div>
                </div>
                <div class="checkbox-item">
                    <label for="discreteZoomCheckbox"><input type="checkbox" id="discreteZoomCheckbox"> Snap to common scales</label>
                </div>
                <div class="checkbox-item">
                    <label for="relativeTimeCheckbox"><input type="checkbox" id="relativeTimeCheckbox"> Relative Time (t=0)</label>
                </div>
                 <div class="checkbox-item">
                    <label for="bwCopyCheckbox"><input type="checkbox" id="bwCopyCheckbox"> B&W Copy (Ctrl+C)</label>
                </div>
            </div>
             <div class="control-panel" id="cursorPanel" style="display: none;">
                <div class="panel-title">Cursor Measurements</div>
                 <div class="control-item"><span class="control-label">ΔX (Time)</span><input type="text" class="control-input" id="deltaX" value="-" readonly></div>
                 <div class="control-item"><span class="control-label">1/ΔX (Freq)</span><input type="text" class="control-input" id="deltaFreq" value="-" readonly></div>
                 <div class="control-item"><span class="control-label">ΔY (Voltage)</span><input type="text" class="control-input" id="deltaY" value="-" readonly></div>
                 <div class="sub-panel">
                     <div class="control-item"><span class="control-label">T1</span><input type="text" class="control-input" id="t1" value="-" readonly></div>
                     <div class="control-item"><span class="control-label">T2</span><input type="text" class="control-input" id="t2" value="-" readonly></div>
                     <div class="control-item"><span class="control-label">V1</span><input type="text" class="control-input" id="v1" value="-" readonly></div>
                     <div class="control-item"><span class="control-label">V2</span><input type="text" class="control-input" id="v2" value="-" readonly></div>
                 </div>
                 <div class="sub-panel">
                     <div class="control-label" style="margin-bottom: 8px;">Cursor Tracking</div>
                     <div style="display: flex; justify-content: space-around; font-size: 13px;">
                         <label><input type="radio" name="cursorTrack" value="null" checked> None</label>
                         <label><input type="radio" name="cursorTrack" value="channel1"> CH1</label>
                         <label><input type="radio" name="cursorTrack" value="channel2"> CH2</label>
                     </div>
                     <div style="display: flex; gap: 8px; margin-top: 12px;">
                          <button class="tool-button" id="setToViewMaxBtn" style="flex:1; font-size: 13px; padding: 6px;">Set to View Max</button>
                          <button class="tool-button" id="setToViewMinBtn" style="flex:1; font-size: 13px; padding: 6px;">Set to View Min</button>
                     </div>
                 </div>
            </div>
        </div>
        <div class="content-area">
            <div class="tab-container" id="tabContainer"></div>
            <div class="toolbar">
                <button class="tool-button" id="resetViewBtn"><i class="fas fa-expand"></i> Reset View</button>
                <button class="tool-button" id="cursorBtn"><i class="fas fa-ruler-combined"></i> Cursors</button>
                <button class="tool-button" id="annotateBtn"><i class="fa-solid fa-square-pen"></i> Annotate</button>
                <button class="tool-button" id="clearAnnotationsBtn" style="display: none;"><i class="fa-solid fa-trash-can"></i> Clear</button>
                <button class="tool-button" id="aboutBtn" style="margin-left: auto;"><i class="fas fa-info-circle"></i> About</button>
            </div>
            <div class="display-area" id="displayArea"><div class="waveform-container" id="waveformContainer"><canvas id="waveformCanvas"></canvas></div></div>
        </div>
    </div>
    <div class="status-bar">
        <div class="window-title">Advanced Rigol WFM Viewer</div>
        <div id="statusText" style="flex: 1;">Ready to load WFM file</div>
        <div>WFM Viewer v13.8</div>
    </div>
    <div class="modal-overlay" id="aboutModal">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2>About WFM Viewer</h2>
            <p>Created by: <b>Ali Nezarati</b></p>
            <p id="aboutDate"></p>
            <h3>Shortcuts</h3>
            <ul class="shortcut-list">
                <li><span>Fit waveform to view</span><code>F Key</code></li>
                <li><span>Copy to Clipboard (PNG)</span><code>Ctrl + C</code></li>
                <li><span>Add Text Annotation</span><code>T Key</code></li>
                <li><span>Zoom to area</span><code>Mouse Drag</code></li>
                <li><span>Measure / Annotate area</span><code>Shift + Drag</code></li>
                <li><span>Pan horizontally</span><code>Shift + Scroll</code></li>
                <li><span>Zoom (Time)</span><code>Ctrl + Scroll</code></li>
                <li><span>Zoom (Voltage)</span><code>Ctrl + Shift + Scroll</code></li>
                <li><span>Reset view</span><code>Double Click</code></li>
                <li><span>Delete Annotation</span><code>Click to Select + Delete Key</code></li>
            </ul>
        </div>
    </div>
    <div class="modal-overlay" id="exportModal">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2>Export Waveform</h2>
             <div class="export-options-container" style="display: flex; flex-direction: column; gap: 20px;">
                 <div>
                     <h3 style="margin-bottom: 8px;">Content</h3>
                     <label style="margin-right: 15px;"><input type="radio" name="content" value="current" checked> Current View</label>
                     <label><input type="radio" name="content" value="all"> All Data</label>
                 </div>
                 <div>
                     <h3 style="margin-bottom: 8px;">Format</h3>
                     <label style="margin-right: 15px;"><input type="radio" name="format" value="png" checked> PNG</label>
                     <label style="margin-right: 15px;"><input type="radio" name="format" value="svg"> SVG</label>
                     <label><input type="radio" name="format" value="csv"> CSV</label>
                 </div>
                 <div>
                     <h3 style="margin-bottom: 8px;">Include & Style</h3>
                     <label style="margin-right: 15px;"><input type="checkbox" id="exportStatsCheckbox" checked> Measurements</label>
                     <label style="margin-right: 15px;"><input type="checkbox" id="exportCursorsCheckbox" checked> Cursors</label>
                     <label style="margin-right: 15px;"><input type="checkbox" id="exportAnnotationsCheckbox" checked> Annotations</label>
                     <label style="margin-right: 15px;"><input type="checkbox" id="bwExportCheckbox"> Black & White</label>
                     <br><br>
                     <label><input type="checkbox" id="exportTableBottomCheckbox"> Place measurements at bottom</label>
                 </div>
                 <div>
                     <label><input type="checkbox" id="ieeeStyleCheckbox"> <b>Use IEEE Style (Publication)</b></label>
                     <div class="ieee-options">
                         <p>Font: Times New Roman, 10pt<br>Background: White</p>
                         <div class="control-item" style="margin-top: 15px; margin-bottom: 5px;">
                             <label for="ieeeWidth" class="control-label">Width (inches):</label>
                             <input type="number" id="ieeeWidth" value="3.45" step="0.05" class="control-input" style="pointer-events: auto; font-family: 'Segoe UI', sans-serif;">
                         </div>
                         <div class="control-item">
                             <label for="ieeeHeight" class="control-label">Height (inches):</label>
                             <input type="number" id="ieeeHeight" value="2.5" step="0.05" class="control-input" style="pointer-events: auto; font-family: 'Segoe UI', sans-serif;">
                         </div>
                     </div>
                 </div>
             </div>
            <div class="modal-footer">
                <button class="modal-button export-confirm-btn" id="exportConfirmBtn">Export</button>
            </div>
        </div>
    </div>
    <div id="drag-overlay">
        <div class="drag-overlay-content">
            <i class="fas fa-file-import"></i>
            <span>Drop WFM file(s) here</span>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('waveformCanvas');
        const ctx = canvas.getContext('2d');
        const tabContainer = document.getElementById('tabContainer');
        const dragOverlay = document.getElementById('drag-overlay');
        const statusText = document.getElementById('statusText');
        const displayArea = document.getElementById('displayArea');

        // --- GLOBAL & APP STATE ---
        let tabStates = [];
        let activeTabIndex = -1;
        let isDraggingFile = false;
        
        // Interaction state (applies to active tab)
        let isDragging = false, isShiftPressed = false;
        let dragStart = { x: 0, y: 0 }, dragEnd = { x: 0, y: 0 };
        let activeInteraction = { type: null, index: -1, handle: null };
        let displayOptions = { showStats: true, discreteZoom: false, relativeTime: false };
        let textAnnotationMode = false;

        // --- CONSTANTS ---
        const X_DIVS = 10, Y_DIVS = 8;
        const PADDING = { top: 30, right: 40, bottom: 60, left: 80 };
        const TIME_PER_POINT = 2e-9, VOLTS_PER_BYTE = 0.04;
        const STD_TIME_SCALES = [1e-9, 2e-9, 5e-9, 1e-8, 2e-8, 5e-8, 1e-7, 2e-7, 5e-7, 1e-6, 2e-6, 5e-6, 1e-5, 2e-5, 5e-5, 1e-4, 2e-4, 5e-4, 1e-3, 2e-3, 5e-3, 1e-2, 2e-2, 5e-2, 0.1, 0.2, 0.5, 1];
        const STD_VOLT_SCALES = [1e-3, 2e-3, 5e-3, 1e-2, 2e-2, 5e-2, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100];

        // --- STATE MANAGEMENT ---
        function createDefaultTabState(fileName) {
            return {
                fileName: fileName,
                waveforms: { channel1: null, channel2: null },
                channelInfo: {
                    channel1: { name: 'Channel 1', visible: true, color: '#00bcf2' },
                    channel2: { name: 'Channel 2', visible: true, color: '#ff4343' }
                },
                drawOrder: ['channel1', 'channel2'],
                view: { startIndex: 0, endIndex: 0, vMin: -128, vMax: 128 },
                cursors: { enabled: false, x1: null, x2: null, y1: null, y2: null, trackingChannel: null },
                annotations: [],
                textAnnotations: [],
                annotationMode: false
            };
        }
        function getActiveState() { return activeTabIndex > -1 ? tabStates[activeTabIndex] : null; }
        
        // --- COORDINATE TRANSFORMATION UTILS ---
        function getPlotArea(width, height) { return { x: PADDING.left, y: PADDING.top, width: width - PADDING.left - PADDING.right, height: height - PADDING.top - PADDING.bottom }; }
        function screenToData(screenPos, currentView) { const { width, height } = canvas.getBoundingClientRect(); const p = getPlotArea(width, height); if (!currentView) return {x: 0, y: 0}; return { x: currentView.startIndex + (screenPos.x - p.x) * (currentView.endIndex - currentView.startIndex) / p.width, y: currentView.vMax - (screenPos.y - p.y) * (currentView.vMax - currentView.vMin) / p.height }; }
        function dataToScreen(dataPos, currentView) { const { width, height } = canvas.getBoundingClientRect(); const p = getPlotArea(width, height); if (!currentView) return {x: 0, y: 0}; return { x: p.x + ((dataPos.x - currentView.startIndex) / (currentView.endIndex - currentView.startIndex)) * p.width, y: p.y + ((currentView.vMax - dataPos.y) / (currentView.vMax - currentView.vMin)) * p.height }; }

        // --- CORE DRAWING LOGIC ---
        function resizeCanvas() { const dpr = window.devicePixelRatio || 1; const rect = document.getElementById('waveformContainer').getBoundingClientRect(); canvas.width = rect.width * dpr; canvas.height = rect.height * dpr; ctx.scale(dpr, dpr); draw(); }

        function draw() {
            requestAnimationFrame(() => {
                const state = getActiveState();
                const { width, height } = canvas.getBoundingClientRect();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, width, height);
                const plotArea = getPlotArea(width, height);

                drawGrid(plotArea);

                if (!state || !state.waveforms.channel1) {
                    drawPlaceholder(plotArea);
                    drawAxisLabels(plotArea, null);
                    return;
                }
                
                drawAxisLabels(plotArea, state.view);

                ctx.save();
                ctx.rect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
                ctx.clip();
                
                state.drawOrder.forEach(ch => { if (state.channelInfo[ch].visible && state.waveforms[ch]) drawWaveform(state.waveforms[ch], state.channelInfo[ch].color, plotArea, state.view); });
                if (state.cursors.enabled) drawCursors(ctx, plotArea, state.cursors, state.view);
                drawAnnotations(ctx, state.view, plotArea, dataToScreen, state.annotations);
                drawTextAnnotations(ctx, state.view, plotArea, dataToScreen, state.textAnnotations);
                
                ctx.restore();
                
                ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
                ctx.strokeRect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
                
                if (displayOptions.showStats) drawStats(plotArea, state);
                if (isDragging) { if (isShiftPressed) drawMeasurementBox(plotArea, state.view); else drawDragRectangle(); }
            });
        }
        
        function formatEng(v, u, p = 3, includeUnit = true){ if(isNaN(v) || v === null) return `- ${includeUnit && u ? u : ''}`.trim(); const s = v < 0 ? '-' : ''; v = Math.abs(v); if (v === 0) return `0 ${includeUnit && u ? u : ''}`.trim(); const k = ['p', 'n', 'µ', 'm', '', 'k', 'M', 'G', 'T']; const i = Math.floor((Math.log10(v) || 0) / 3); const d = v / 10**(i * 3); return (s + d.toPrecision(p) + (k[i + 4] || '') + (includeUnit && u ? ` ${u}` : '')).trim(); }
        function drawGrid(p){ctx.strokeStyle='#333';ctx.lineWidth=1;for(let i=0;i<=X_DIVS;i++){const x=p.x+i/X_DIVS*p.width;ctx.beginPath();ctx.moveTo(x,p.y);ctx.lineTo(x,p.y+p.height);ctx.stroke()}for(let i=0;i<=Y_DIVS;i++){const y=p.y+i/Y_DIVS*p.height;ctx.beginPath();ctx.moveTo(p.x,y);ctx.lineTo(p.x+p.width,y);ctx.stroke()}}
        function drawAxisLabels(p, view){ctx.fillStyle='#a0a0a0';ctx.font='14px Segoe UI'; if (!view) { ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.fillText('V', p.x-10, p.y + p.height/2); ctx.textAlign='center'; ctx.textBaseline='top'; ctx.fillText('s', p.x + p.width/2, p.y+p.height+10); return; } const vR=view.vMax-view.vMin;if(vR>0){ctx.textAlign='right';ctx.textBaseline='middle';for(let i=0;i<=Y_DIVS;i++){const y=p.y+i/Y_DIVS*p.height;const v=view.vMax-i/Y_DIVS*vR;ctx.fillText(formatEng(v*VOLTS_PER_BYTE,'V', 3, false),p.x-10,y)}}const tS=(view.endIndex-view.startIndex);if(tS>0){const tStart=view.startIndex*TIME_PER_POINT;const tSpan=tS*TIME_PER_POINT;ctx.textAlign='center';ctx.textBaseline='top';for(let i=0;i<=X_DIVS;i++){const x=p.x+i/X_DIVS*p.width;const timeVal = displayOptions.relativeTime ? (i/X_DIVS*tSpan) : (tStart+i/X_DIVS*tSpan);ctx.fillText(formatEng(timeVal,'s', 3, false),x,p.y+p.height+10)}}}
        function drawWaveform(d,c,p,view){ctx.strokeStyle=c;ctx.lineWidth=1.5;ctx.beginPath();const pts=view.endIndex-view.startIndex;const vR=view.vMax-view.vMin;if(vR===0)return;if(pts>p.width*2){const dec=decimate(d,view.startIndex,view.endIndex,p.width);for(let i=0;i<dec.length;i++){const{min,max}=dec[i];const x=p.x+i;const y_min=p.y+p.height-((min-view.vMin)/vR)*p.height;const y_max=p.y+p.height-((max-view.vMin)/vR)*p.height;if(i===0)ctx.moveTo(x,y_min);ctx.lineTo(x,y_min);ctx.lineTo(x,y_max)}}else if(pts>1){for(let i=0;i<pts;i++){const v=d[Math.floor(view.startIndex)+i]-127;const x=p.x+i/(pts-1)*p.width;const y=p.y+p.height-((v-view.vMin)/vR)*p.height;if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y)}}ctx.stroke();}
        function decimate(d, s, e, w){const dec=[];const step=(e-s)/w;for(let i=0;i<w;i++){const start=Math.floor(s+i*step),end=Math.floor(s+(i+1)*step);let min=128,max=-128;for(let j=start;j<end;j++){if(d[j]!==undefined){const v=d[j]-127;if(v<min)min=v;if(v>max)max=v}}dec.push({min:min===128?-128:min,max})}return dec}
        function drawPlaceholder(p){ctx.fillStyle='#aaa';ctx.font='18px sans-serif';ctx.textAlign='center';ctx.fillText('No waveform loaded',p.x+p.width/2,p.y+p.height/2);ctx.fillText('Click "Load WFM File" or drop file here',p.x+p.width/2,p.y+p.height/2+30)}
        function drawDragRectangle(){ctx.fillStyle='rgba(0,120,215,0.3)';ctx.strokeStyle='#0078d7';ctx.lineWidth=1;const x=Math.min(dragStart.x,dragEnd.x),y=Math.min(dragStart.y,dragEnd.y),w=Math.abs(dragStart.x-dragEnd.x),h=Math.abs(dragStart.y-dragEnd.y);ctx.fillRect(x,y,w,h);ctx.strokeRect(x,y,w,h)}

        // --- UI & FEATURES DRAWING ---
        function drawStatsTable(context, state, options) {
            const { x, y, isExport, colors } = options;
            const visibleChannels = state.drawOrder.filter(ch => state.channelInfo[ch].visible && state.waveforms[ch]);
            if (visibleChannels.length === 0) return { width: 0, height: 0 };

            const activeMeasures = {};
            if (isExport) {
                activeMeasures.max = true; activeMeasures.min = true; activeMeasures.avg = true; activeMeasures.rms = true;
            } else {
                activeMeasures.max = document.getElementById('showMaxCheckbox').checked;
                activeMeasures.min = document.getElementById('showMinCheckbox').checked;
                activeMeasures.avg = document.getElementById('showAvgCheckbox').checked;
                activeMeasures.rms = document.getElementById('showRmsCheckbox').checked;
            }

            const measureOrder = ['max', 'min', 'avg', 'rms'];
            const measureLabels = { max: 'Max', min: 'Min', avg: 'Avg', rms: 'RMS' };
            const rows = measureOrder.filter(m => activeMeasures[m]);
            if (rows.length === 0) return { width: 0, height: 0 };

            const allStats = {};
            visibleChannels.forEach(ch => { allStats[ch] = calculateStats(state.waveforms[ch], state.view); });
            
            context.font = isExport ? '10pt Consolas, monospace' : '13px Consolas, monospace';
            context.textBaseline = 'middle';

            const rowHeaders = rows.map(r => measureLabels[r]);
            const cellPadding = isExport ? 8 : 10;
            const lineHeight = isExport ? 20 : 22;

            const colWidths = [0, ...visibleChannels.map(() => 0)];
            colWidths[0] = Math.max(...rowHeaders.map(h => context.measureText(h).width));
            rows.forEach(rowKey => {
                visibleChannels.forEach((ch, chIndex) => {
                    const text = formatEng(allStats[ch][rowKey], 'V', 3);
                    colWidths[chIndex + 1] = Math.max(colWidths[chIndex + 1], context.measureText(text).width);
                });
            });

            for (let i = 0; i < colWidths.length; i++) { colWidths[i] += cellPadding * 2; }
            
            const tableWidth = colWidths.reduce((a, b) => a + b, 0);
            const tableHeight = rows.length * lineHeight + (isExport ? 0 : cellPadding);
            if (!x && !y) return { width: tableWidth, height: tableHeight };

            context.fillStyle = colors.bg;
            context.fillRect(x, y, tableWidth, tableHeight);
            context.strokeStyle = colors.grid;
            context.lineWidth = 1;
            context.strokeRect(x, y, tableWidth, tableHeight);

            let currentY = y + lineHeight / 2 + (isExport ? 0 : cellPadding/2);
            rows.forEach((rowKey, rowIndex) => {
                let currentX = x;
                context.fillStyle = colors.text;
                context.textAlign = 'left';
                context.fillText(rowHeaders[rowIndex], currentX + cellPadding, currentY);
                currentX += colWidths[0];
                
                context.textAlign = 'right';
                visibleChannels.forEach((ch, chIndex) => {
                    const text = formatEng(allStats[ch][rowKey], 'V', 3);
                    context.fillStyle = colors.trace1 ? (chIndex === 0 ? colors.trace1 : colors.trace2) : state.channelInfo[ch].color;
                    context.fillText(text, currentX + colWidths[chIndex + 1] - cellPadding, currentY);
                    currentX += colWidths[chIndex + 1];
                });
                currentY += lineHeight;
            });

            let currentX = x + colWidths[0];
            for(let i = 1; i < colWidths.length; i++) {
                context.beginPath(); context.moveTo(currentX, y); context.lineTo(currentX, y + tableHeight); context.stroke();
                currentX += colWidths[i];
            }
            return { width: tableWidth, height: tableHeight };
        }
        function drawStats(plotArea, state) {
            if (!state || !state.waveforms.channel1) return;
            drawStatsTable(ctx, state, {
                x: plotArea.x + 10, y: plotArea.y + 10, isExport: false,
                colors: { bg: 'rgba(0, 0, 0, 0.6)', grid: '#555555', text: '#fff' }
            });
        }
        function drawMeasurementBox(plotArea, view) { drawDragRectangle(); const {x: t1, y: v2} = screenToData({x: Math.min(dragStart.x, dragEnd.x), y: Math.min(dragStart.y, dragEnd.y)}, view); const {x: t2, y: v1} = screenToData({x: Math.max(dragStart.x, dragEnd.x), y: Math.max(dragStart.y, dragEnd.y)}, view); const dt = (t2 - t1) * TIME_PER_POINT, dV = (v2 - v1) * VOLTS_PER_BYTE, freq = dt > 0 ? 1 / dt : 0; const state = getActiveState(); ctx.fillStyle = state.annotationMode ? '#ffc107' : '#fff'; ctx.font = '14px Consolas'; ctx.textAlign = 'left'; const tX = Math.max(dragStart.x, dragEnd.x) + 5, tY = Math.max(dragStart.y, dragEnd.y); ctx.fillText(`Δt: ${formatEng(dt,'s')}`, tX, tY - 30); ctx.fillText(`1/Δt: ${formatEng(freq,'Hz')}`, tX, tY - 15); ctx.fillText(`ΔV: ${formatEng(dV,'V')}`, tX, tY); }
        function drawCursors(context, plotArea, cursors, view) { context.save(); context.setLineDash([6, 4]); context.lineWidth = 1.5; context.strokeStyle = '#f0ad4e'; const x1_s = dataToScreen({x: cursors.x1, y: 0}, view).x, x2_s = dataToScreen({x: cursors.x2, y: 0}, view).x; if (x1_s >= plotArea.x && x1_s <= plotArea.x + plotArea.width) { context.beginPath(); context.moveTo(x1_s, plotArea.y); context.lineTo(x1_s, plotArea.y + plotArea.height); context.stroke(); } if (x2_s >= plotArea.x && x2_s <= plotArea.x + plotArea.width) { context.beginPath(); context.moveTo(x2_s, plotArea.y); context.lineTo(x2_s, plotArea.y + plotArea.height); context.stroke(); } context.strokeStyle = '#32f0ad'; const y1_s = dataToScreen({x: 0, y: cursors.y1}, view).y, y2_s = dataToScreen({x: 0, y: cursors.y2}, view).y; if (y1_s >= plotArea.y && y1_s <= plotArea.y + plotArea.height) { context.beginPath(); context.moveTo(plotArea.x, y1_s); context.lineTo(plotArea.x + plotArea.width, y1_s); context.stroke(); } if (y2_s >= plotArea.y && y2_s <= plotArea.y + plotArea.height) { context.beginPath(); context.moveTo(plotArea.x, y2_s); context.lineTo(plotArea.x + plotArea.width, y2_s); context.stroke(); } context.restore(); if(context === ctx) updateCursorReadouts(cursors); }
        function drawAnnotations(context, targetView, plotArea, dataToScreenFunc, annotations) {
            const handleSize = 8;
            annotations.forEach((box, index) => {
                const p1 = dataToScreenFunc({x: box.t1, y: box.v1}, targetView);
                const p2 = dataToScreenFunc({x: box.t2, y: box.v2}, targetView);
                const x = Math.min(p1.x, p2.x), y = Math.min(p1.y, p2.y);
                const w = Math.abs(p1.x - p2.x), h = Math.abs(p1.y - p2.y);
                const isSelected = activeInteraction.type === 'annotation' && activeInteraction.index === index;
                context.strokeStyle = isSelected ? '#ffffff' : '#ffc107';
                context.fillStyle = 'rgba(255, 193, 7, 0.15)';
                context.lineWidth = isSelected ? 2 : 1;
                context.fillRect(x, y, w, h);
                context.strokeRect(x, y, w, h);
                
                const dt = (box.t2 - box.t1) * TIME_PER_POINT, dV = (box.v2 - box.v1) * VOLTS_PER_BYTE;
                context.fillStyle = isSelected ? '#ffffff' : '#ffc107';
                context.font = '10pt "Times New Roman"';
                context.textAlign = 'left';

                const placeTextOutside = (y + h > plotArea.y + plotArea.height - 30) || h < 35;
                let textY, textBaseline;
                if (placeTextOutside) { textY = y - 5; textBaseline = 'bottom'; } 
                else { textY = y + 5; textBaseline = 'top'; }
                
                context.textBaseline = textBaseline;
                context.fillText(`Δt: ${formatEng(dt, 's')}`, x + 5, textY);
                context.fillText(`ΔV: ${formatEng(dV, 'V')}`, x + 5, textY + (placeTextOutside ? -15 : 15));
                
                if(isSelected && context === ctx){
                    context.fillStyle = '#ffffff';
                    context.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize);
                    context.fillRect(x + w - handleSize/2, y - handleSize/2, handleSize, handleSize);
                    context.fillRect(x - handleSize/2, y + h - handleSize/2, handleSize, handleSize);
                    context.fillRect(x + w - handleSize/2, y + h - handleSize/2, handleSize, handleSize);
                }
            });
        }
         function drawTextAnnotations(context, targetView, plotArea, dataToScreenFunc, textAnnotations) {
            textAnnotations.forEach(ann => {
                const pos = dataToScreenFunc({x: ann.x, y: ann.y}, targetView);
                context.fillStyle = 'rgba(0, 0, 0, 0.6)';
                context.font = '14px Segoe UI';
                const textWidth = context.measureText(ann.text).width;
                context.fillRect(pos.x, pos.y - 18, textWidth + 10, 22);
                context.fillStyle = '#f0ad4e';
                context.textAlign = 'left';
                context.textBaseline = 'middle';
                context.fillText(ann.text, pos.x + 5, pos.y - 7);
            });
        }

        // --- UI UPDATES & STATE MANAGEMENT ---
        function fitView(){const s=getActiveState();if(!s || !s.waveforms.channel1)return;let min=255,max=0;s.drawOrder.filter(c=>s.channelInfo[c].visible&&s.waveforms[c]).forEach(c=>{const d=s.waveforms[c];for(let v of d){if(v<min)min=v;if(v>max)max=v}});min-=127;max-=127;const m=(max-min)*0.1;s.view={startIndex:0,endIndex:s.waveforms.channel1.length,vMin:min-m-10||-10,vMax:max+m+10||10};updateControlsFromView(s);draw()}
        function resetView() { if (getActiveState()) fitView(); }
        function updateControlsFromView(state){if(!state || !state.waveforms.channel1)return;const vRange=(state.view.vMax-state.view.vMin);const tRange=(state.view.endIndex-state.view.startIndex);if(vRange===0||tRange===0)return;document.getElementById('voltageScale').value=formatEng(vRange*VOLTS_PER_BYTE,'V');document.getElementById('timeScale').value=formatEng(tRange*TIME_PER_POINT,'s')}
        function updateCursorReadouts(cursors) { const t1 = cursors.x1 * TIME_PER_POINT, t2 = cursors.x2 * TIME_PER_POINT; const v1 = cursors.y1 * VOLTS_PER_BYTE, v2 = cursors.y2 * VOLTS_PER_BYTE; const dt = Math.abs(t2 - t1), dv = Math.abs(v2 - v1); const freq = dt > 0 ? 1 / dt : 0; document.getElementById('deltaX').value = formatEng(dt, 's'); document.getElementById('deltaFreq').value = formatEng(freq, 'Hz'); document.getElementById('deltaY').value = formatEng(dv, 'V'); document.getElementById('t1').value = formatEng(t1, 's'); document.getElementById('t2').value = formatEng(t2, 's'); document.getElementById('v1').value = formatEng(v1, 'V'); document.getElementById('v2').value = formatEng(v2, 'V'); }
        function calculateStats(data, view) {
            let min = 255, max = 0, sum = 0, sumSq = 0;
            const s = Math.floor(view.startIndex), e = Math.ceil(view.endIndex);
            const count = e - s;
            if (count <= 0) return { min: NaN, max: NaN, avg: NaN, rms: NaN };

            for (let i = s; i < e; i++) {
                const rawVal = data[i];
                if (rawVal !== undefined) {
                    if (rawVal < min) min = rawVal;
                    if (rawVal > max) max = rawVal;
                    const voltVal = (rawVal - 127) * VOLTS_PER_BYTE;
                    sum += voltVal;
                    sumSq += voltVal * voltVal;
                }
            }
            const avg = sum / count;
            const rms = Math.sqrt(sumSq / count);
            return {
                min: (min - 127) * VOLTS_PER_BYTE,
                max: (max - 127) * VOLTS_PER_BYTE,
                avg: avg,
                rms: rms
            };
        }

        // --- FILE & TAB HANDLING ---
        function handleFileSelect(e) { for (const file of e.target.files) { if(file.name.toLowerCase().endsWith('.wfm')) loadFile(file); } e.target.value = ''; }
        function loadFile(file) {
            statusText.textContent=`Loading ${file.name}...`;
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const dataCh1 = new Uint8Array(e.target.result, 10);
                    const dataCh2 = new Uint8Array(dataCh1.length);
                    for (let i = 1; i < dataCh1.length; i++) { dataCh2[i] = 127 + (dataCh1[i] - dataCh1[i - 1]) * 4; }
                    dataCh2[0] = 127;

                    const newState = createDefaultTabState(file.name);
                    newState.waveforms.channel1 = dataCh1;
                    newState.waveforms.channel2 = dataCh2;
                    
                    const newIndex = tabStates.length;
                    tabStates.push(newState);
                    addTabToUI(file.name, newIndex);
                    switchToTab(newIndex);
                    statusText.textContent = `Loaded: ${file.name}`;
                } catch(err) {
                    statusText.textContent = "Error processing file.";
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function addTabToUI(fileName, index) {
            const tab = document.createElement('div');
            tab.className = 'tab-item';
            tab.dataset.index = index;
            tab.innerHTML = `<span class="tab-name" title="${fileName}">${fileName}</span><span class="tab-close">&times;</span>`;
            tab.addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-close')) {
                    e.stopPropagation();
                    closeTab(index);
                } else {
                    switchToTab(index);
                }
            });
            tabContainer.appendChild(tab);
        }

        function switchToTab(index) {
            if (index < 0 || index >= tabStates.length) return;
            activeTabIndex = index;

            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.classList.toggle('active', parseInt(tab.dataset.index) === index);
            });
            
            updateUIFromState();
            fitView();
        }

        function closeTab(index) {
            tabStates.splice(index, 1);
            tabContainer.innerHTML = '';
            tabStates.forEach((state, i) => addTabToUI(state.fileName, i));
            
            if (activeTabIndex === index) {
                let newIndex = Math.min(index, tabStates.length - 1);
                if (newIndex >= 0) {
                    switchToTab(newIndex);
                } else {
                    activeTabIndex = -1;
                    updateUIFromState();
                    draw();
                }
            } else if (activeTabIndex > index) {
                activeTabIndex--;
                switchToTab(activeTabIndex);
            } else {
                 switchToTab(activeTabIndex);
            }
        }
        
        function updateUIFromState() {
            const state = getActiveState();
            if (!state) {
                document.getElementById('fileInfo').innerHTML = `<div>Drop a file or click Load</div><div>Points: -</div>`;
                ['timeScale', 'voltageScale', 'deltaX', 'deltaFreq', 'deltaY', 't1', 't2', 'v1', 'v2'].forEach(id => document.getElementById(id).value = '-');
                document.getElementById('cursorPanel').style.display = 'none';
                document.getElementById('cursorBtn').classList.remove('active');
                document.getElementById('annotateBtn').classList.remove('active');
                document.getElementById('clearAnnotationsBtn').style.display = 'none';
                return;
            }
            
            document.getElementById('fileInfo').innerHTML = `<div>${state.fileName}</div><div>Points: ${state.waveforms.channel1.length}</div>`;
            document.getElementById('ch1NameInput').value = state.channelInfo.channel1.name;
            document.getElementById('ch2NameInput').value = state.channelInfo.channel2.name;
            document.querySelector('.channel-button[data-channel="channel1"]').classList.toggle('active', state.channelInfo.channel1.visible);
            document.querySelector('.channel-button[data-channel="channel2"]').classList.toggle('active', state.channelInfo.channel2.visible);
            document.querySelector(`.channel-button[data-channel="${state.drawOrder[0]}"] .ch-order`).textContent='(Back)'; 
            document.querySelector(`.channel-button[data-channel="${state.drawOrder[1]}"] .ch-order`).textContent='(Front)';
            document.getElementById('cursorBtn').classList.toggle('active', state.cursors.enabled);
            document.getElementById('cursorPanel').style.display = state.cursors.enabled ? 'block' : 'none';
            if(state.cursors.enabled) updateCursorReadouts(state.cursors);
            document.querySelector(`input[name="cursorTrack"][value="${state.cursors.trackingChannel || 'null'}"]`).checked = true;
            document.getElementById('annotateBtn').classList.toggle('active', state.annotationMode || textAnnotationMode);
            document.getElementById('clearAnnotationsBtn').style.display = (state.annotationMode || textAnnotationMode) ? 'flex' : 'none';
            
            const showStats = document.getElementById('showStatsCheckbox').checked;
            document.getElementById('measurement-controls').style.display = showStats ? 'block' : 'none';

            updateControlsFromView(state);
        }

        // --- EVENT HANDLERS ---
        function getInteractionAtPos(pos) { const state=getActiveState(); if(!state) return {type:null}; const handleSize = 8, tol = handleSize / 2; for (let i = state.annotations.length - 1; i >= 0; i--) { const box = state.annotations[i]; const p1 = dataToScreen({x: box.t1, y: box.v1}, state.view), p2 = dataToScreen({x: box.t2, y: box.v2}, state.view); const x=Math.min(p1.x,p2.x), y=Math.min(p1.y,p2.y), w=Math.abs(p1.x-p2.x), h=Math.abs(p1.y-p2.y); const isSelected = activeInteraction.type === 'annotation' && activeInteraction.index === i; if (isSelected) { if (Math.abs(pos.x - x) < tol && Math.abs(pos.y - y) < tol) return {type: 'annotation', index: i, handle: 'tl'}; if (Math.abs(pos.x - (x+w)) < tol && Math.abs(pos.y - y) < tol) return {type: 'annotation', index: i, handle: 'tr'}; if (Math.abs(pos.x - x) < tol && Math.abs(pos.y - (y+h)) < tol) return {type: 'annotation', index: i, handle: 'bl'}; if (Math.abs(pos.x - (x+w)) < tol && Math.abs(pos.y - (y+h)) < tol) return {type: 'annotation', index: i, handle: 'br'}; } if (pos.x > x && pos.x < x + w && pos.y > y && pos.y < y + h) return {type: 'annotation', index: i, handle: 'body'}; } if (state.cursors.enabled) { const x1_s = dataToScreen({x: state.cursors.x1, y: 0}, state.view).x, x2_s = dataToScreen({x: state.cursors.x2, y: 0}, state.view).x; const y1_s = dataToScreen({x: 0, y: state.cursors.y1}, state.view).y, y2_s = dataToScreen({x: 0, y: state.cursors.y2}, state.view).y; if (Math.abs(pos.x - x1_s) < tol) return { type: 'cursor', handle: 'x1' }; if (Math.abs(pos.x - x2_s) < tol) return { type: 'cursor', handle: 'x2' }; if (Math.abs(pos.y - y1_s) < tol) return { type: 'cursor', handle: 'y1' }; if (Math.abs(pos.y - y2_s) < tol) return { type: 'cursor', handle: 'y2' }; } return { type: null }; }
        canvas.addEventListener('mousedown', e => { const state=getActiveState(); if (!state) return; if(textAnnotationMode) { createTextAnnotationInput(e); return; } activeInteraction = getInteractionAtPos({x: e.offsetX, y: e.offsetY}); if (activeInteraction.type) { isDragging = false; draw(); return; } if (state.cursors.enabled) { const plotArea = getPlotArea(canvas.clientWidth, canvas.clientHeight); const mousePos = {x: e.offsetX, y: e.offsetY}; if (mousePos.y > plotArea.y + plotArea.height && mousePos.x > plotArea.x && mousePos.x < plotArea.x + plotArea.width) { const targetX = screenToData(mousePos, state.view).x; if (Math.abs(targetX - state.cursors.x1) < Math.abs(targetX - state.cursors.x2)) state.cursors.x1 = targetX; else state.cursors.x2 = targetX; trackCursors(); draw(); return; } if (mousePos.x < plotArea.x && mousePos.y > plotArea.y && mousePos.y < plotArea.y + plotArea.height) { const targetY = screenToData(mousePos, state.view).y; state.cursors.trackingChannel = null; document.querySelector(`input[name="cursorTrack"][value="null"]`).checked = true; if (Math.abs(targetY - state.cursors.y1) < Math.abs(targetY - state.cursors.y2)) state.cursors.y1 = targetY; else state.cursors.y2 = targetY; draw(); return; } } isDragging = true; isShiftPressed = e.shiftKey; dragStart = { x: e.offsetX, y: e.offsetY }; dragEnd = { ...dragStart }; });
        canvas.addEventListener('mousemove', e => { const state=getActiveState(); if (!state) return; const mousePos = { x: e.offsetX, y: e.offsetY }; const dataPos = screenToData(mousePos, state.view); if (activeInteraction.type === 'cursor') { if (activeInteraction.handle.startsWith('x')) { state.cursors[activeInteraction.handle] = dataPos.x; trackCursors(); } else { state.cursors[activeInteraction.handle] = dataPos.y; state.cursors.trackingChannel = null; document.querySelector(`input[name="cursorTrack"][value="null"]`).checked = true;} draw(); } else if (activeInteraction.type === 'annotation') { const box = state.annotations[activeInteraction.index]; const lastDataPos = screenToData(dragStart, state.view); const dx = dataPos.x - lastDataPos.x, dy = dataPos.y - lastDataPos.y; if (activeInteraction.handle === 'body') { box.t1 += dx; box.t2 += dx; box.v1 += dy; box.v2 += dy; } else { if (activeInteraction.handle.includes('l')) box.t1 = dataPos.x; if (activeInteraction.handle.includes('r')) box.t2 = dataPos.x; if (activeInteraction.handle.includes('t')) box.v2 = dataPos.y; if (activeInteraction.handle.includes('b')) box.v1 = dataPos.y; } dragStart = mousePos; draw(); } else if(isDragging) { dragEnd = mousePos; draw(); } else { const interaction = getInteractionAtPos(mousePos); let cursorStyle = 'crosshair'; if(textAnnotationMode) cursorStyle = 'text'; else if (interaction.type === 'annotation') cursorStyle = interaction.handle === 'body' ? 'move' : 'pointer'; else if (interaction.type === 'cursor') cursorStyle = interaction.handle.startsWith('x') ? 'ew-resize' : 'ns-resize'; canvas.style.cursor = cursorStyle; } });
        canvas.addEventListener('mouseup', e => { const state=getActiveState(); if (!state) return; if (activeInteraction.type === 'annotation') { const box = state.annotations[activeInteraction.index]; if (box.t1 > box.t2) [box.t1, box.t2] = [box.t2, box.t1]; if (box.v1 > box.v2) [box.v1, box.v2] = [box.v2, box.v1]; if (activeInteraction.handle !== 'body') activeInteraction.handle = 'body'; draw(); return; } if (activeInteraction.type) { activeInteraction = { type: null }; draw(); return; } if (!isDragging) return; isDragging = false; if (isShiftPressed) { if (state.annotationMode && Math.abs(dragEnd.x - dragStart.x) > 5) { const {x: t1_raw, y: v2_raw} = screenToData({x: Math.min(dragStart.x, dragEnd.x), y: Math.min(dragStart.y, dragEnd.y)}, state.view); const {x: t2_raw, y: v1_raw} = screenToData({x: Math.max(dragStart.x, dragEnd.x), y: Math.max(dragStart.y, dragEnd.y)}, state.view); state.annotations.push({ t1: t1_raw, v1: v1_raw, t2: t2_raw, v2: v2_raw }); } draw(); return; } if (Math.abs(dragEnd.x - dragStart.x) < 10 || Math.abs(dragEnd.y - dragStart.y) < 10) { draw(); return; } const { x: nStartI, y: nVMax } = screenToData({x: Math.min(dragStart.x, dragEnd.x), y: Math.min(dragStart.y, dragEnd.y)}, state.view); const { x: nEndI, y: nVMin } = screenToData({x: Math.max(dragStart.x, dragEnd.x), y: Math.max(dragStart.y, dragEnd.y)}, state.view); if (nEndI - nStartI < 10) return; state.view = { startIndex: nStartI, endIndex: nEndI, vMin: nVMin, vMax: nVMax }; updateControlsFromView(state); draw(); });
        canvas.addEventListener('dblclick', resetView);
        canvas.addEventListener('wheel', e => { const state=getActiveState(); if(!state)return; e.preventDefault(); const pA=getPlotArea(canvas.clientWidth, canvas.clientHeight); const currentTRange = state.view.endIndex - state.view.startIndex, currentVRange = state.view.vMax - state.view.vMin; if (e.ctrlKey) { const mouseXRatio = (e.offsetX - pA.x) / pA.width, mouseYRatio = 1 - (e.offsetY - pA.y) / pA.height; if (displayOptions.discreteZoom) { const direction = e.deltaY < 0 ? 1 : -1; if (e.shiftKey) { const currentVScale = currentVRange * VOLTS_PER_BYTE / Y_DIVS; let currentIndex = STD_VOLT_SCALES.findIndex(s => s >= currentVScale); if (currentIndex === -1) currentIndex = STD_VOLT_SCALES.length -1; if (direction < 0 && STD_VOLT_SCALES[currentIndex] >= currentVScale) currentIndex--; const newIndex = Math.max(0, Math.min(STD_VOLT_SCALES.length - 1, currentIndex + direction)); const newVScale = STD_VOLT_SCALES[newIndex]; const newVRange = (newVScale / VOLTS_PER_BYTE) * Y_DIVS; const pivotV = state.view.vMin + currentVRange * mouseYRatio; state.view.vMin = pivotV - newVRange * mouseYRatio; state.view.vMax = pivotV + newVRange * (1 - mouseYRatio); } else { const currentTScale = currentTRange * TIME_PER_POINT / X_DIVS; let currentIndex = STD_TIME_SCALES.findIndex(s => s >= currentTScale); if (currentIndex === -1) currentIndex = STD_TIME_SCALES.length -1; if (direction < 0 && STD_TIME_SCALES[currentIndex] >= currentTScale) currentIndex--; const newIndex = Math.max(0, Math.min(STD_TIME_SCALES.length - 1, currentIndex + direction)); const newTScale = STD_TIME_SCALES[newIndex]; const newTRange = (newTScale / TIME_PER_POINT) * X_DIVS; const pivotT = state.view.startIndex + currentTRange * mouseXRatio; state.view.startIndex = pivotT - newTRange * mouseXRatio; state.view.endIndex = pivotT + newTRange * (1 - mouseXRatio); } } else { const z = e.deltaY < 0 ? 0.85 : 1.15; if (e.shiftKey) { const pivotV = state.view.vMin + currentVRange * mouseYRatio; state.view.vMin = pivotV - (currentVRange * z * mouseYRatio); state.view.vMax = pivotV + (currentVRange * z * (1 - mouseYRatio)); } else { const pivotT = state.view.startIndex + currentTRange * mouseXRatio; state.view.startIndex = pivotT - (currentTRange * z * mouseXRatio); state.view.endIndex = pivotT + (currentTRange * z * (1 - mouseXRatio)); } } } else if(e.shiftKey) { const p = currentTRange * 0.1 * Math.sign(e.deltaY); state.view.startIndex += p; state.view.endIndex += p; } state.view.startIndex = Math.max(0, state.view.startIndex); state.view.endIndex = Math.min(state.waveforms.channel1.length, state.view.endIndex); if (state.view.endIndex - state.view.startIndex < 1) { state.view.endIndex = state.view.startIndex + 1; } if (state.view.vMax - state.view.vMin < 1) { state.view.vMax = state.view.vMin + 1; } updateControlsFromView(state); draw(); },{passive:false});
        
        // --- Drag & Drop File Handlers ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => document.body.addEventListener(eventName, e => e.preventDefault()));
        ['dragenter', 'dragover'].forEach(eventName => document.body.addEventListener(eventName, () => { if (!isDraggingFile) { dragOverlay.style.display = 'flex'; isDraggingFile = true; } }));
        document.body.addEventListener('dragleave', (e) => { if (e.relatedTarget === null) { dragOverlay.style.display = 'none'; isDraggingFile = false; }});
        document.body.addEventListener('drop', e => { dragOverlay.style.display = 'none'; isDraggingFile = false; for (const file of e.dataTransfer.files) { if(file.name.toLowerCase().endsWith('.wfm')) loadFile(file); } });
        
        // --- BUTTON & OTHER EVENT LISTENERS ---
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('resetViewBtn').addEventListener('click', resetView);
        document.getElementById('swapOrderBtn').addEventListener('click', () => { const s=getActiveState(); if (!s) return; s.drawOrder.reverse(); document.querySelector(`.channel-button[data-channel="${s.drawOrder[0]}"] .ch-order`).textContent='(Back)'; document.querySelector(`.channel-button[data-channel="${s.drawOrder[1]}"] .ch-order`).textContent='(Front)'; draw(); });
        document.querySelectorAll('.channel-button').forEach(btn => { btn.addEventListener('click', e => { const s=getActiveState(); if (!s) return; const ch=e.currentTarget.dataset.channel; e.currentTarget.classList.toggle('active'); s.channelInfo[ch].visible=e.currentTarget.classList.contains('active'); draw(); }); });
        document.getElementById('ch1NameInput').addEventListener('input', e => { const s=getActiveState(); if (!s) return; s.channelInfo.channel1.name = e.target.value || 'Channel 1'; draw(); });
        document.getElementById('ch2NameInput').addEventListener('input', e => { const s=getActiveState(); if (!s) return; s.channelInfo.channel2.name = e.target.value || 'Channel 2'; draw(); });
        document.getElementById('showStatsCheckbox').addEventListener('change', e => { displayOptions.showStats = e.target.checked; document.getElementById('measurement-controls').style.display = e.target.checked ? 'block' : 'none'; draw(); });
        document.querySelectorAll('.meas-toggle').forEach(cb => cb.addEventListener('change', draw));
        document.getElementById('discreteZoomCheckbox').addEventListener('change', e => { displayOptions.discreteZoom = e.target.checked; });
        document.getElementById('relativeTimeCheckbox').addEventListener('change', e => { displayOptions.relativeTime = e.target.checked; draw(); });
        document.getElementById('cursorBtn').addEventListener('click', () => { const s=getActiveState(); if(!s) return; s.cursors.enabled = !s.cursors.enabled; document.getElementById('cursorBtn').classList.toggle('active'); document.getElementById('cursorPanel').style.display = s.cursors.enabled ? 'block' : 'none'; if (s.cursors.enabled && s.cursors.x1 === null) { const spanT=s.view.endIndex-s.view.startIndex, spanV=s.view.vMax-s.view.vMin; s.cursors.x1=s.view.startIndex+spanT*0.25; s.cursors.x2=s.view.startIndex+spanT*0.75; s.cursors.y1=s.view.vMin+spanV*0.25; s.cursors.y2=s.view.vMin+spanV*0.75; trackCursors();} draw(); });
        document.getElementById('annotateBtn').addEventListener('click', (e) => { const s=getActiveState(); if(!s) return; s.annotationMode = !s.annotationMode; textAnnotationMode = false; e.currentTarget.classList.toggle('active', s.annotationMode); document.getElementById('clearAnnotationsBtn').style.display = s.annotationMode ? 'flex' : 'none'; });
        document.getElementById('clearAnnotationsBtn').addEventListener('click', () => { const s=getActiveState(); if(!s) return; s.annotations = []; s.textAnnotations = []; activeInteraction = {type: null}; draw(); });
        document.addEventListener('keydown', e => { if (e.target.tagName === 'INPUT') return; if (e.key.toLowerCase() === 'f') resetView(); if (e.ctrlKey && e.key.toLowerCase() === 'c') { e.preventDefault(); exportToClipboard(); } if (e.key === 'Delete' && activeInteraction.type === 'annotation' && activeInteraction.index > -1) { const s=getActiveState(); if(!s) return; s.annotations.splice(activeInteraction.index, 1); activeInteraction = {type: null}; draw(); } if(e.key.toLowerCase() === 't') { toggleTextAnnotationMode(); } if(e.key === 'Escape') { if(textAnnotationMode) toggleTextAnnotationMode(); } });
        
        // --- CURSOR FEATURE LISTENERS ---
        document.querySelectorAll('input[name="cursorTrack"]').forEach(radio => { radio.addEventListener('change', e => { const s = getActiveState(); if (s) { s.cursors.trackingChannel = e.target.value === 'null' ? null : e.target.value; trackCursors(); draw(); }}); });
        document.getElementById('setToViewMaxBtn').addEventListener('click', () => setCursorsToExtrema('max'));
        document.getElementById('setToViewMinBtn').addEventListener('click', () => setCursorsToExtrema('min'));
        
        // --- CURSOR FEATURE LOGIC ---
        function trackCursors() { const s = getActiveState(); if (!s || !s.cursors.trackingChannel || !s.waveforms[s.cursors.trackingChannel]) return; const data = s.waveforms[s.cursors.trackingChannel]; const i1 = Math.round(s.cursors.x1); if(data[i1] !== undefined) s.cursors.y1 = data[i1] - 127; const i2 = Math.round(s.cursors.x2); if(data[i2] !== undefined) s.cursors.y2 = data[i2] - 127; }
        function findViewExtrema(channels) { const s = getActiveState(); if (!s) return null; let viewMin = { val: Infinity, index: -1, ch: null }, viewMax = { val: -Infinity, index: -1, ch: null }; const start = Math.floor(s.view.startIndex), end = Math.ceil(s.view.endIndex); channels.forEach(ch => { const data = s.waveforms[ch]; for (let i = start; i < end; i++) { const val = data[i]; if (val < viewMin.val) { viewMin = { val, index: i, ch }; } if (val > viewMax.val) { viewMax = { val, index: i, ch }; } } }); return { min: viewMin, max: viewMax }; }
        function setCursorsToExtrema(type) { const s = getActiveState(); if (!s) return; const visibleChannels = s.drawOrder.filter(ch => s.channelInfo[ch].visible); if (visibleChannels.length === 0) return; const extrema = findViewExtrema(visibleChannels); if(type === 'max' && extrema.max.index !== -1) { s.cursors.x1 = extrema.max.index; s.cursors.y1 = extrema.max.val - 127; } else if (type === 'min' && extrema.min.index !== -1) { s.cursors.x2 = extrema.min.index; s.cursors.y2 = extrema.min.val - 127; } updateCursorReadouts(s.cursors); draw(); }
        
        // --- TEXT ANNOTATION LOGIC ---
        function toggleTextAnnotationMode() { const s = getActiveState(); if(!s) return; textAnnotationMode = !textAnnotationMode; if(textAnnotationMode && s.annotationMode) s.annotationMode = false; canvas.style.cursor = textAnnotationMode ? 'text' : 'crosshair'; document.getElementById('annotateBtn').classList.toggle('active', textAnnotationMode || s.annotationMode); document.getElementById('clearAnnotationsBtn').style.display = (textAnnotationMode || s.annotationMode) ? 'flex' : 'none'; }
        function createTextAnnotationInput(e) { let existingInput = document.getElementById('text-annotation-input'); if(existingInput) existingInput.remove(); const s = getActiveState(); const dataPos = screenToData({x: e.offsetX, y: e.offsetY}, s.view); const input = document.createElement('input'); input.type = 'text'; input.id = 'text-annotation-input'; input.style.left = `${e.offsetX}px`; input.style.top = `${e.offsetY}px`; displayArea.appendChild(input); input.focus(); input.addEventListener('keydown', (ev) => { if(ev.key === 'Enter') { if(input.value) { s.textAnnotations.push({ x: dataPos.x, y: dataPos.y, text: input.value }); } input.remove(); toggleTextAnnotationMode(); draw(); } else if (ev.key === 'Escape') { input.remove(); toggleTextAnnotationMode(); } }); }
        
        // --- MODAL & EXPORT LOGIC ---
        function setupModals() {
            const aboutModal=document.getElementById('aboutModal'), exportModal=document.getElementById('exportModal'); 
            document.getElementById('aboutBtn').addEventListener('click', () => { document.getElementById('aboutDate').textContent=`Date: ${new Date().toLocaleDateString('en-SG',{weekday:'long',year:'numeric',month:'long',day:'numeric'})}`; aboutModal.style.display='flex'; });
            document.getElementById('exportBtn').addEventListener('click', () => { if(getActiveState()) exportModal.style.display='flex'; });
            [aboutModal, exportModal].forEach(m => { m.querySelector('.modal-close').addEventListener('click',()=>m.style.display='none'); m.addEventListener('click', e => { if(e.target===m)m.style.display='none'; }); });
            document.getElementById('exportConfirmBtn').addEventListener('click', () => { 
                const options = { 
                    content: document.querySelector('input[name="content"]:checked').value, 
                    format: document.querySelector('input[name="format"]:checked').value, 
                    isIEEE: document.getElementById('ieeeStyleCheckbox').checked,
                    isBW: document.getElementById('bwExportCheckbox').checked,
                    tableAtBottom: document.getElementById('exportTableBottomCheckbox').checked,
                    ieeeWidth: parseFloat(document.getElementById('ieeeWidth').value), 
                    ieeeHeight: parseFloat(document.getElementById('ieeeHeight').value), 
                    exportStats: document.getElementById('exportStatsCheckbox').checked, 
                    exportCursors: document.getElementById('exportCursorsCheckbox').checked, 
                    exportAnnotations: document.getElementById('exportAnnotationsCheckbox').checked,
                }; 
                executeExport(options); 
                exportModal.style.display = 'none'; 
            });
        }
        
        async function exportToClipboard() {
            const state = getActiveState(); if (!state) return;
            const isBW = document.getElementById('bwCopyCheckbox').checked;
            try {
                const blob = await generatePngBlob({ 
                    content: 'current', 
                    isIEEE: false,
                    isBW: isBW,
                    exportStats: true, 
                    exportCursors: state.cursors.enabled, 
                    exportAnnotations: true
                });
                await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]);
                statusText.textContent = 'Copied to clipboard!';
                setTimeout(() => { if (getActiveState()) statusText.textContent = `Loaded: ${getActiveState().fileName}`; }, 2000);
            } catch (err) { statusText.textContent = 'Error: Failed to copy to clipboard.'; console.error(err); }
        }

        function generatePngBlob(o) {
            return new Promise((resolve) => {
                const state = getActiveState(); if(!state) return resolve(null);
                const container = document.getElementById('waveformContainer');
                const targetView = {...state.view};

                let x, h;
                if (o.isIEEE) {
                    const DPI = 300;
                    x = (o.ieeeWidth || 3.45) * DPI;
                    h = (o.ieeeHeight || 2.5) * DPI;
                } else {
                    x = container.clientWidth;
                    h = container.clientHeight;
                }
                
                const p = {top:h*0.1,right:x*0.05,bottom:h*0.18,left:x*0.13};
                const plotArea = {x:p.left,y:p.top,width:x-p.left-p.right,height:h-p.top-p.bottom};
                const dataToScreenPNG = (dataPos) => ({ x: plotArea.x + ((dataPos.x - targetView.startIndex) / (targetView.endIndex - targetView.startIndex || 1)) * plotArea.width, y: plotArea.y + ((targetView.vMax - dataPos.y) / (targetView.vMax - targetView.vMin || 1)) * plotArea.height });

                const colors = {
                    bg: o.isIEEE || o.isBW ? '#fff' : '#1e1e1e',
                    grid: o.isIEEE || o.isBW ? '#e0e0e0' : '#333',
                    text: o.isIEEE || o.isBW ? '#000' : '#a0a0a0',
                    border: o.isIEEE || o.isBW ? '#000' : '#888',
                    trace1: o.isIEEE || o.isBW ? '#000' : state.channelInfo.channel1.color,
                    trace2: o.isIEEE || o.isBW ? '#888' : state.channelInfo.channel2.color,
                };
                
                let tableSize = { width: 0, height: 0 };
                if (o.exportStats && o.tableAtBottom) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tableSize = drawStatsTable(tempCtx, state, { isExport: true });
                    h += tableSize.height + 40;
                }

                const c = document.createElement('canvas'); c.width=x; c.height=h; const C=c.getContext('2d');
                
                C.fillStyle=colors.bg; C.fillRect(0,0,x,h); C.strokeStyle=colors.grid; C.lineWidth=1;
                for(let i=0;i<=X_DIVS;i++){C.beginPath(); C.moveTo(plotArea.x+i/X_DIVS*plotArea.width,plotArea.y); C.lineTo(plotArea.x+i/X_DIVS*plotArea.width,plotArea.y+plotArea.height); C.stroke();}
                for(let i=0;i<=Y_DIVS;i++){C.beginPath(); C.moveTo(plotArea.x,plotArea.y+i/Y_DIVS*plotArea.height); C.lineTo(plotArea.x+plotArea.width,plotArea.y+i/Y_DIVS*plotArea.height); C.stroke();}
                C.save(); C.rect(plotArea.x,plotArea.y,plotArea.width,plotArea.height); C.clip();
                const visCh=state.drawOrder.filter(ch=>state.channelInfo[ch].visible&&state.waveforms[ch]);
                visCh.forEach((ch, i)=>{ 
                    let color = i === 0 ? colors.trace1 : colors.trace2;
                    C.strokeStyle=color; C.lineWidth=2; C.beginPath(); 
                    const pts=targetView.endIndex-targetView.startIndex, vR=targetView.vMax-targetView.vMin; 
                    if(vR > 0 && pts > plotArea.width) { 
                        decimate(state.waveforms[ch],targetView.startIndex,targetView.endIndex,plotArea.width).forEach((d,j)=>{ const X=plotArea.x+j, y_min=plotArea.y+plotArea.height-((d.min-targetView.vMin)/vR)*plotArea.height, y_max=plotArea.y+plotArea.height-((d.max-targetView.vMin)/vR)*plotArea.height; if(j===0)C.moveTo(X,y_min); C.lineTo(X,y_min); C.lineTo(X,y_max); });
                    } else if (vR > 0 && pts > 1) { 
                        for(let j=0;j<pts;j++){ const val=state.waveforms[ch][Math.floor(targetView.startIndex)+j]-127; const X=plotArea.x+j/(pts-1)*plotArea.width, Y=plotArea.y+plotArea.height-((val-targetView.vMin)/vR)*plotArea.height; if(j===0)C.moveTo(X,Y);else C.lineTo(X,Y);}
                    } 
                    C.stroke(); 
                });
                if (o.exportCursors && state.cursors.enabled) { drawCursors(C, plotArea, state.cursors, targetView); }
                if (o.exportAnnotations) { drawAnnotations(C, targetView, plotArea, dataToScreenPNG, state.annotations); drawTextAnnotations(C, targetView, plotArea, dataToScreenPNG, state.textAnnotations); }
                C.restore();
                
                if (o.exportStats) {
                    const tableColors = { 
                        bg: (o.isIEEE || o.isBW) ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.6)',
                        grid: (o.isIEEE || o.isBW) ? '#ccc' : '#555',
                        text: (o.isIEEE || o.isBW) ? '#000' : '#fff', 
                        trace1: colors.trace1, trace2: colors.trace2 
                    };
                    if (o.tableAtBottom) {
                        drawStatsTable(C, state, { x: plotArea.x, y: plotArea.y + plotArea.height + 60, isExport: true, colors: tableColors});
                    } else {
                        drawStatsTable(C, state, { x: plotArea.x + 10, y: plotArea.y + 10, isExport: true, colors: tableColors });
                    }
                }
                
                C.strokeStyle = colors.border; C.lineWidth = 1.5; C.strokeRect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
                C.fillStyle=colors.text; C.font=o.isIEEE?'10pt Times New Roman':'14px Segoe UI'; C.textAlign='right'; C.textBaseline = 'middle'; const vR=targetView.vMax-targetView.vMin; if(vR>0){for(let i=0;i<=Y_DIVS;i++){C.fillText(formatEng((targetView.vMax-i/Y_DIVS*vR)*VOLTS_PER_BYTE,'V',3,false),plotArea.x-8,plotArea.y+i/Y_DIVS*plotArea.height)}} C.textAlign='center'; C.textBaseline = 'top'; const tS=targetView.endIndex-targetView.startIndex; if(tS>0){const tStart=targetView.startIndex*TIME_PER_POINT, tSpan=tS*TIME_PER_POINT; for(let i=0;i<=X_DIVS;i++){ const timeVal = displayOptions.relativeTime ? (i/X_DIVS*tSpan) : (tStart+i/X_DIVS*tSpan); C.fillText(formatEng(timeVal,'s',3,false),plotArea.x+i/X_DIVS*plotArea.width,plotArea.y+plotArea.height+15)}} if(o.isIEEE){ C.font = '10pt Times New Roman'; C.fillText("Time (s)",plotArea.x+plotArea.width/2,plotArea.y+plotArea.height+45); C.save(); C.translate(plotArea.x-85,plotArea.y+plotArea.height/2); C.rotate(-Math.PI/2); C.textAlign='center'; C.fillText("Voltage (V)",0,0); C.restore(); }
                c.toBlob(blob => resolve(blob), 'image/png');
            });
        }

        function executeExport(o) {
            const state = getActiveState(); if(!state) return;
            const format = o.format || 'png';
            if (format === 'csv') { exportAsCSV(o, state); return; }
            if (format === 'png') { generatePngBlob(o).then(blob => { const a=document.createElement('a'); a.download=`${state.fileName.replace('.wfm','')}.png`; a.href=URL.createObjectURL(blob); a.click(); URL.revokeObjectURL(a.href); }); return; }
            
            // --- SVG EXPORT ---
            const container = document.getElementById('waveformContainer');
            let W, H;
            if (o.isIEEE) {
                W = o.ieeeWidth * 96; H = o.ieeeHeight * 96;
            } else {
                W = container.clientWidth; H = container.clientHeight;
            }

            const p = o.isIEEE 
                ? { x: W * 0.18, y: H * 0.1, width: W * (1 - 0.18 - 0.05), height: H * (1 - 0.1 - 0.25) }
                : { x: W * 0.15, y: H * 0.1, width: W * (1 - 0.15 - 0.05), height: H * (1 - 0.1 - 0.20) };
            
            const colors = {
                bg: o.isIEEE || o.isBW ? '#fff' : '#1e1e1e',
                grid: o.isIEEE || o.isBW ? '#e0e0e0' : '#333',
                text: o.isIEEE || o.isBW ? '#000' : '#a0a0a0',
                border: o.isIEEE || o.isBW ? '#000' : '#888',
                trace1: o.isIEEE || o.isBW ? '#000' : state.channelInfo.channel1.color,
                trace2: o.isIEEE || o.isBW ? '#888' : state.channelInfo.channel2.color,
            };
            
            const targetView = o.content === 'all' ? {startIndex: 0, endIndex: state.waveforms.channel1.length, vMin: state.view.vMin, vMax: state.view.vMax} : {...state.view};
            if (o.content === 'all') { let min=128,max=-128; for(let v of state.waveforms.channel1){if(v<min)min=v;if(v>max)max=v}; targetView.vMin=min-127-10; targetView.vMax=max-127+10;}
            
            const font = o.isIEEE ? 'Times New Roman' : 'Segoe UI';
            let tableHeight = 0;
            if(o.exportStats && o.tableAtBottom) {
                 const lineHeight = 20;
                 const rows = ['max', 'min', 'avg', 'rms'];
                 tableHeight = (rows.length + 1) * lineHeight + 40;
                 H += tableHeight;
            }
            
            let svg = `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg" font-family="${font}" font-size="10pt"><defs><clipPath id="clip"><rect x="0" y="0" width="${p.width}" height="${p.height}" /></clipPath></defs><rect width="100%" height="100%" fill="${colors.bg}"/>`;
            svg += `<g transform="translate(${p.x}, ${p.y})" stroke="${colors.grid}" stroke-width="1">`;
            for(let j=1; j<4; j++){ let i = j * (X_DIVS / 4); svg += `<line x1="${i/X_DIVS*p.width}" y1="0" x2="${i/X_DIVS*p.width}" y2="${p.height}" />`; }
            for(let j=1; j<4; j++){ let i = j * (Y_DIVS / 4); svg += `<line x1="0" y1="${i/Y_DIVS*p.height}" x2="${p.width}" y2="${i/Y_DIVS*p.height}" />`; }
            svg += `</g><g transform="translate(${p.x}, ${p.y})" clip-path="url(#clip)">`;
            const visCh = state.drawOrder.filter(c => state.channelInfo[c].visible && state.waveforms[c]);
            visCh.forEach((ch, i) => { let color = i === 0 ? colors.trace1 : colors.trace2; let pathData = '', pts = targetView.endIndex - targetView.startIndex, vR = targetView.vMax - targetView.vMin; if (pts > 1 && vR > 0) { for(let j=0; j<pts; j++){ const val=state.waveforms[ch][Math.floor(targetView.startIndex)+j]-127; const x=(j/(pts-1))*p.width, y=p.height-((val-targetView.vMin)/vR)*p.height; pathData+=(j===0?'M':'L')+`${x.toFixed(2)},${y.toFixed(2)} `}} svg += `<path d="${pathData}" stroke="${color}" fill="none" stroke-width="1.5" />`; });
            
            if (o.isIEEE) {
                let legendYOffset = 15;
                visCh.forEach((ch, i) => {
                    let color = i === 0 ? colors.trace1 : colors.trace2;
                    const yPos = legendYOffset + (i * 20);
                    svg += `<g transform="translate(10, 10)"><line x1="0" y1="${yPos}" x2="25" y2="${yPos}" stroke="${color}" stroke-width="2" />`;
                    svg += `<text x="35" y="${yPos}" dominant-baseline="middle" fill="${colors.text}">${state.channelInfo[ch].name}</text></g>`;
                });
            }
            if (o.exportCursors && state.cursors.enabled) { svg += drawCursorsSVG(state, targetView, p); }
            if (o.exportAnnotations) { svg += drawAnnotationsSVG(state, targetView, p); svg += drawTextAnnotationsSVG(state, targetView, p); }
            
            svg += `</g><rect x="${p.x}" y="${p.y}" width="${p.width}" height="${p.height}" fill="none" stroke="${colors.border}" stroke-width="1.5" /><g fill="${colors.text}">`;
            const vR=targetView.vMax-targetView.vMin; if(vR > 0){ for(let j=0; j<=4; j++){ let i = j * (Y_DIVS/4); svg+=`<text x="${p.x-8}" y="${p.y+(1-i/Y_DIVS)*p.height}" text-anchor="end" dominant-baseline="middle">${formatEng((targetView.vMin+i/Y_DIVS*vR)*VOLTS_PER_BYTE,'V',3,false)}</text>`}}
            const tS=targetView.endIndex-targetView.startIndex; if(tS > 0){ const tStart=targetView.startIndex*TIME_PER_POINT, tSpan=tS*TIME_PER_POINT; for(let j=0; j<=4; j++){ let i = j * (X_DIVS/4); const timeVal = displayOptions.relativeTime ? (i/X_DIVS*tSpan) : (tStart+i/X_DIVS*tSpan); svg+=`<text x="${p.x+i/X_DIVS*p.width}" y="${p.y+p.height+20}" text-anchor="middle">${formatEng(timeVal,'s',3,false)}</text>`}}
            const titleFontSize = o.isIEEE ? '10pt' : '16px'; 
            svg += `<text x="${p.x+p.width/2}" y="${p.y+p.height + 45}" text-anchor="middle" font-size="${titleFontSize}">${"Time (s)"}</text></g>`;
            svg += `<g transform="translate(${o.isIEEE ? W*0.04 : W*0.06}, ${p.y + p.height/2}) rotate(-90)" fill="${colors.text}"><text x="0" y="0" text-anchor="middle" font-size="${titleFontSize}">${"Voltage (V)"}</text></g>`;
            
            if(o.exportStats && o.tableAtBottom) {
                const allStats = {}; visCh.forEach(ch => { allStats[ch] = calculateStats(state.waveforms[ch], targetView); });
                const rows = {Max: 'max', Min: 'min', Avg: 'avg', RMS: 'rms'};
                let tableX = p.x, tableY = p.y + p.height + 70;
                let table = `<g transform="translate(${tableX}, ${tableY})" font-size="10pt" font-family="Consolas, monospace">`;
                const colWidths = [60, 100, 100], lineHeight = 20, tableH = (Object.keys(rows).length) * lineHeight + 5;
                const tableW = colWidths[0] + visCh.length * colWidths[1];
                table += `<rect x="0" y="0" width="${tableW}" height="${tableH}" fill="none" stroke="${colors.grid}" />`;
                let y = lineHeight / 2 + 2;
                for (const [label, key] of Object.entries(rows)) {
                    table += `<text x="5" y="${y}" fill="${colors.text}">${label}</text>`;
                    visCh.forEach((ch, i) => { table += `<text x="${colWidths[0] + i*colWidths[1] + colWidths[1] - 5}" y="${y}" text-anchor="end" fill="${i === 0 ? colors.trace1 : colors.trace2}">${formatEng(allStats[ch][key], 'V')}</text>`; });
                    y += lineHeight;
                }
                table += `<line x1="${colWidths[0]}" y1="0" x2="${colWidths[0]}" y2="${tableH}" stroke="${colors.grid}"/>`;
                table += `</g>`;
                svg += table;
            }

            svg += `</svg>`;
            const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([svg],{type:'image/svg+xml;charset=utf-8'})); a.download=`${state.fileName.replace('.wfm','')}.svg`; a.click();
        }

        function drawCursorsSVG(state, targetView, p) {
            let svg = '';
            const dataToScreenSVG = (dataPos) => ({ x: (dataPos.x - targetView.startIndex) / (targetView.endIndex - targetView.startIndex || 1) * p.width, y: (targetView.vMax - dataPos.y) / (targetView.vMax - targetView.vMin || 1) * p.height });
            const {x1, x2, y1, y2} = state.cursors;
            const x1_s = dataToScreenSVG({x: x1, y: 0}).x;
            const x2_s = dataToScreenSVG({x: x2, y: 0}).x;
            const y1_s = dataToScreenSVG({x: 0, y: y1}).y;
            const y2_s = dataToScreenSVG({x: 0, y: y2}).y;
            svg += `<line x1="${x1_s}" y1="0" x2="${x1_s}" y2="${p.height}" stroke="#f0ad4e" stroke-width="1.5" stroke-dasharray="6 4" />`;
            svg += `<line x1="${x2_s}" y1="0" x2="${x2_s}" y2="${p.height}" stroke="#f0ad4e" stroke-width="1.5" stroke-dasharray="6 4" />`;
            svg += `<line x1="0" y1="${y1_s}" x2="${p.width}" y2="${y1_s}" stroke="#32f0ad" stroke-width="1.5" stroke-dasharray="6 4" />`;
            svg += `<line x1="0" y1="${y2_s}" x2="${p.width}" y2="${y2_s}" stroke="#32f0ad" stroke-width="1.5" stroke-dasharray="6 4" />`;
            return svg;
        }

        function drawAnnotationsSVG(state, targetView, p) {
            let svg = '';
            const dataToScreenSVG = (dataPos) => ({ x: (dataPos.x - targetView.startIndex) / (targetView.endIndex - targetView.startIndex || 1) * p.width, y: (targetView.vMax - dataPos.y) / (targetView.vMax - targetView.vMin || 1) * p.height });
            state.annotations.forEach(box => {
                const p1 = dataToScreenSVG({x: box.t1, y: box.v1});
                const p2 = dataToScreenSVG({x: box.t2, y: box.v2});
                const x = Math.min(p1.x, p2.x), y = Math.min(p1.y, p2.y);
                const w = Math.abs(p1.x - p2.x), h = Math.abs(p1.y - p2.y);
                svg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" stroke="#ffc107" stroke-width="1" fill="rgba(255, 193, 7, 0.15)" />`;
                const dt = (box.t2 - box.t1) * TIME_PER_POINT, dV = (box.v2 - box.v1) * VOLTS_PER_BYTE;
                svg += `<text x="${x+5}" y="${y+15}" font-size="10pt" fill="#ffc107">Δt: ${formatEng(dt, 's')}</text>`;
                svg += `<text x="${x+5}" y="${y+30}" font-size="10pt" fill="#ffc107">ΔV: ${formatEng(dV, 'V')}</text>`;
            });
            return svg;
        }

        function drawTextAnnotationsSVG(state, targetView, p) {
             let svg = '';
            const dataToScreenSVG = (dataPos) => ({ x: (dataPos.x - targetView.startIndex) / (targetView.endIndex - targetView.startIndex || 1) * p.width, y: (targetView.vMax - dataPos.y) / (targetView.vMax - targetView.vMin || 1) * p.height });
             state.textAnnotations.forEach(ann => {
                const pos = dataToScreenSVG({x: ann.x, y: ann.y});
                svg += `<text x="${pos.x + 5}" y="${pos.y - 7}" fill="#f0ad4e" font-size="14px" dominant-baseline="middle">${ann.text}</text>`;
             });
             return svg;
        }

        function exportAsCSV(o, state){let c='Time (s),Channel 1 (V),Channel 2 (V)\n';const s=o.content==='all'?0:Math.floor(state.view.startIndex),e=o.content==='all'?state.waveforms.channel1.length:Math.floor(state.view.endIndex); const timeOffset = displayOptions.relativeTime ? (s * TIME_PER_POINT) : 0; for(let i=s;i<e;i++){c+=`${((i*TIME_PER_POINT)-timeOffset).toExponential(6)},${((state.waveforms.channel1[i]-127)*VOLTS_PER_BYTE).toExponential(6)},${((state.waveforms.channel2[i]-127)*VOLTS_PER_BYTE).toExponential(6)}\n`}const a=document.createElement("a");a.href=URL.createObjectURL(new Blob([c],{type:'text/csv;charset=utf-8;'}));a.setAttribute("download",`${state.fileName.replace('.wfm','')}.csv`);a.click()}

        // --- INITIALIZATION ---
        setupModals();
        new ResizeObserver(resizeCanvas).observe(document.getElementById('waveformContainer'));
        draw(); 
    });
</script>
</body>
</html>
