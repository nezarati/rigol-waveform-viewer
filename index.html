<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal WFM Waveform Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; }
        html, body { height: 100%; overflow: hidden; }
        body { background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); color: #ffffff; padding: 12px; display: flex; flex-direction: column; font-size: 14px; }
        .main-container { flex: 1; display: flex; gap: 20px; background: #2d2d2d; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4); min-height: 0; }
        .sidebar { width: 340px; background: #3c3c3c; padding: 20px; display: flex; flex-direction: column; gap: 24px; overflow-y: auto; transition: width 0.3s ease; }
        .content-area { flex: 1; display: flex; flex-direction: column; background: #252525; min-width: 0; }
        
        /* --- TAB STYLES --- */
        .tab-container { display: flex; background: #252525; flex-shrink: 0; border-bottom: 1px solid #4a4a4a; }
        .tab-item { padding: 10px 15px; cursor: pointer; background: #3c3c3c; color: #ccc; border-right: 1px solid #252525; display: flex; align-items: center; gap: 8px; max-width: 200px; }
        .tab-item:hover { background: #4a4a4a; }
        .tab-item.active { background: #0078d7; color: white; font-weight: 500; }
        .tab-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .tab-close { margin-left: auto; width: 18px; height: 18px; line-height: 18px; text-align: center; border-radius: 50%; }
        .tab-close:hover { background-color: rgba(255,255,255,0.2); }
        .tab-item.active .tab-close:hover { background-color: rgba(0,0,0,0.2); }
        #createOverlapBtn { margin-left: auto; background: none; border: none; color: #ccc; padding: 0 15px; cursor: pointer; font-size: 16px; transition: all 0.2s; }
        #createOverlapBtn:hover { color: white; background: #4a4a4a; }

        .toolbar { height: 48px; background: #3c3c3c; display: flex; align-items: center; padding: 0 16px; gap: 16px; border-bottom: 1px solid #4a4a4a; flex-shrink: 0; }
        .tool-button { padding: 8px 16px; background: #5e5e5e; border: none; border-radius: 4px; color: white; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 15px; transition: background 0.2s; }
        .tool-button:hover { background: #6a6a6a; }
        .tool-button:active { transform: translateY(1px); }
        .tool-button.active { background: #0078d7; }
        .display-area { flex: 1; position: relative; min-height: 0; }
        .waveform-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1e1e1e; border-radius: 4px; overflow: hidden; cursor: grab; }
        canvas { width: 100%; height: 100%; display: block; }
        .status-bar { height: 28px; background: #0078d7; display: flex; align-items: center; justify-content: space-between; padding: 0 16px; font-size: 14px; flex-shrink: 0; margin-top: 12px; }
        .window-title { font-size: 13px; font-weight: 500; color: #cccccc; margin-right: 20px; }
        .panel-title { font-size: 15px; font-weight: 600; margin-bottom: 16px; color: #cccccc; border-bottom: 1px solid #555; padding-bottom: 8px; }
        .file-panel, .control-panel { background: #383838; border-radius: 6px; padding: 16px; }
        .file-info { background: #454545; padding: 12px; border-radius: 4px; margin-top: 12px; font-size: 14px; word-wrap: break-word;}
        .control-item { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .control-label { font-size: 14px; color: #a0a0a0; }
        .control-input { width: 110px; padding: 4px 8px; background: #454545; border: 1px solid #5a5a5a; border-radius: 4px; color: white; font-size: 13px; font-family: Consolas, monospace;}
        .checkbox-item { margin-top: 15px; font-size: 14px; display: flex; align-items: center; gap: 8px; }
        .channel-button { display: flex; align-items: center; justify-content: space-between; padding: 9px 12px; background: #454545; border: none; border-radius: 4px; color: white; cursor: pointer; margin-bottom: 8px; width: 100%; transition: background 0.2s; font-size: 15px; gap: 8px;}
        .channel-button.active { /* Color is now set dynamically via JS */ }
        .channel-button .ch-name { flex-grow: 1; display: flex; align-items: center; gap: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none; }
        .channel-button .ch-order { font-size: 12px; color: #ccc; }
        .ch-color-picker { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 22px; height: 22px; background-color: transparent; border: 1px solid #888; border-radius: 4px; cursor: pointer; padding: 2px; }
        .ch-color-picker::-webkit-color-swatch { border-radius: 2px; border: none; }
        .ch-color-picker::-moz-color-swatch { border-radius: 2px; border: none; }
        .file-input { display: none; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 100; display: none; align-items: center; justify-content: center; }
        .modal-content { background: #3c3c3c; padding: 30px; border-radius: 8px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); width: 90%; max-width: 500px; position: relative; border-top: 3px solid #0078d7; }
        .modal-close { position: absolute; top: 10px; right: 15px; font-size: 28px; color: #aaa; cursor: pointer; line-height: 1; }
        .modal-close:hover { color: white; }
        .modal-content h2 { margin-bottom: 20px; font-size: 20px; }
        .shortcut-list { list-style: none; padding-left: 0; }
        .shortcut-list li { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #555; }
        .shortcut-list code { background: #2d2d2d; padding: 3px 7px; border-radius: 4px; font-family: Consolas, monospace; }
        .ieee-options { background: #4a4a4a; padding: 15px; border-radius: 5px; margin-top: 10px; display: none; }
        #ieeeStyleCheckbox:checked ~ .ieee-options { display: block; }
        .modal-footer { margin-top: 30px; text-align: right; }
        .modal-button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 15px; }
        .modal-confirm-btn { background: #0078d7; color: white; }
        .modal-confirm-btn:hover { background: #005a9e; }
        .modal-cancel-btn { background: #5e5e5e; color: white; margin-right: 10px; }
        .modal-cancel-btn:hover { background: #6a6a6a; }
        .sub-panel { margin-top: 12px; border-top: 1px solid #555; padding-top: 12px; }
        #text-annotation-input { position: fixed; background: #2d2d2d; color: white; border: 1px solid #0078d7; padding: 5px; z-index: 110; border-radius: 3px; }
        
        /* --- DRAG & DROP OVERLAY --- */
        #drag-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 120, 215, 0.7); z-index: 200; display: none; align-items: center; justify-content: center; pointer-events: none; }
        .drag-overlay-content { text-align: center; color: white; }
        .drag-overlay-content i { font-size: 80px; }
        .drag-overlay-content span { display: block; font-size: 24px; margin-top: 20px; }

        #fileDetailsContent, .load-options-info { font-family: Consolas, monospace; font-size: 12px; line-height: 1.6; }
        #fileDetailsContent div, .load-options-info div { display: flex; justify-content: space-between; margin-bottom: 4px; }
        #fileDetailsContent span:first-child, .load-options-info span:first-child { color: #a0a0a0; padding-right: 15px;}
        .load-options-channels { margin-top: 15px; }
        .load-options-channel-item { background: #4a4a4a; padding: 12px; border-radius: 5px; margin-bottom: 10px; }
        .load-options-channel-item h4 { margin-bottom: 10px; border-bottom: 1px solid #666; padding-bottom: 5px; }
        #loadOptionsModal .control-item { margin-bottom: 8px; }


        @media (max-width: 768px) {
            body { padding: 0; }
            .main-container { flex-direction: column; height: 100%; border-radius: 0; gap: 0; }
            .sidebar { width: 100%; border-bottom: 1px solid #4a4a4a; flex-shrink: 0; height: auto; max-height: 45vh; }
            .content-area { min-height: 55vh; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <div class="file-panel">
                <div class="panel-title">File Operations</div>
                <button class="tool-button" id="loadBtn" style="width: 100%"><i class="fas fa-folder-open"></i> Load File</button>
                <input type="file" id="fileInput" class="file-input" accept=".wfm,.csv,.graphx" multiple>
                <button class="tool-button" id="saveSessionBtn" style="width: 100%; margin-top: 12px;"><i class="fas fa-project-diagram"></i> Save Session</button>
                <button class="tool-button" id="exportBtn" style="width: 100%; margin-top: 12px;"><i class="fas fa-file-export"></i> Export...</button>
                <div class="file-info" id="fileInfo"><div style="margin-bottom: 8px">Drop a file or click Load</div><div>Points: -</div></div>
            </div>
             <div class="control-panel">
                <div class="panel-title">Channel Display</div>
                <div id="channelButtonContainer">
                </div>
                <button class="tool-button" id="swapOrderBtn" style="width:100%; margin-top: 8px;"><i class="fas fa-layer-group"></i> Swap Order</button>
            </div>
            <div class="control-panel">
                <div class="panel-title">Display Controls</div>
                <div class="control-item"><span class="control-label">Time Scale (s/div)</span><input type="text" class="control-input" id="timeScale" value="-"></div>
                <div id="voltageScaleContainer"></div>
                <div class="checkbox-item">
                    <label for="showStatsCheckbox"><input type="checkbox" id="showStatsCheckbox" checked> Show Measurements</label>
                </div>
                <div id="measurement-controls" class="sub-panel" style="margin-top: 5px; padding-top: 5px;">
                    <div style="display: flex; justify-content: space-around; font-size: 13px; flex-wrap: wrap; gap: 10px;">
                        <label><input type="checkbox" class="meas-toggle" id="showMaxCheckbox" checked> Max</label>
                        <label><input type="checkbox" class="meas-toggle" id="showMinCheckbox" checked> Min</label>
                        <label><input type="checkbox" class="meas-toggle" id="showAvgCheckbox" checked> Avg</label>
                        <label><input type="checkbox" class="meas-toggle" id="showRmsCheckbox" checked> RMS</label>
                    </div>
                </div>
                <div class="checkbox-item">
                    <label for="discreteZoomCheckbox"><input type="checkbox" id="discreteZoomCheckbox"> Snap to common scales</label>
                </div>
                <div class="checkbox-item">
                    <label for="relativeTimeCheckbox"><input type="checkbox" id="relativeTimeCheckbox"> Relative Time (t=0)</label>
                </div>
                 <div class="checkbox-item">
                    <label for="wbCopyCheckbox"><input type="checkbox" id="wbCopyCheckbox"> White BG Copy (Ctrl+C)</label>
                </div>
                <div class="checkbox-item">
                    <label for="separateViewCheckbox"><input type="checkbox" id="separateViewCheckbox"> Separate Diagrams</label>
                </div>
            </div>
             <div class="control-panel" id="cursorPanel" style="display: none;">
                <div class="panel-title">Cursor Measurements</div>
                  <div class="control-item"><span class="control-label">ΔX (Time)</span><input type="text" class="control-input" id="deltaX" value="-" readonly></div>
                  <div class="control-item"><span class="control-label">1/ΔX (Freq)</span><input type="text" class="control-input" id="deltaFreq" value="-" readonly></div>
                  <div class="control-item"><span class="control-label">ΔY (<span id="cursorYUnit">V</span>)</span><input type="text" class="control-input" id="deltaY" value="-" readonly></div>
                  <div class="sub-panel">
                      <div class="control-item"><span class="control-label">T1</span><input type="text" class="control-input" id="t1" value="-" readonly></div>
                      <div class="control-item"><span class="control-label">T2</span><input type="text" class="control-input" id="t2" value="-" readonly></div>
                      <div class="control-item"><span class="control-label">V1</span><input type="text" class="control-input" id="v1" value="-" readonly></div>
                      <div class="control-item"><span class="control-label">V2</span><input type="text" class="control-input" id="v2" value="-" readonly></div>
                  </div>
                  <div class="sub-panel">
                      <div class="control-label" style="margin-bottom: 8px;">Cursor Tracking</div>
                      <div id="cursorTrackContainer" style="display: flex; justify-content: space-around; font-size: 13px; flex-wrap: wrap; gap: 5px;">
                                <label><input type="radio" name="cursorTrack" value="null" checked> None</label>
                          </div>
                      <div style="display: flex; gap: 8px; margin-top: 12px;">
                                <button class="tool-button" id="setToViewMaxBtn" style="flex:1; font-size: 13px; padding: 6px;">Set to View Max</button>
                                <button class="tool-button" id="setToViewMinBtn" style="flex:1; font-size: 13px; padding: 6px;">Set to View Min</button>
                      </div>
                  </div>
            </div>
            <div class="control-panel" id="fileDetailsPanel" style="display: none;">
                <div class="panel-title">File Details</div>
                <div id="fileDetailsContent"></div>
            </div>
        </div>
        <div class="content-area">
            <div class="tab-container" id="tabContainer">
                 <button id="createOverlapBtn" title="Create Overlap Tab from Visible Channels"><i class="fas fa-layer-group"></i></button>
            </div>
            <div class="toolbar">
                <button class="tool-button" id="resetViewBtn"><i class="fas fa-expand"></i> Reset Offsets & View</button>
                <button class="tool-button" id="cursorBtn"><i class="fas fa-ruler-combined"></i> Cursors</button>
                <button class="tool-button" id="annotateBtn"><i class="fa-solid fa-square-pen"></i> Annotate</button>
                <button class="tool-button" id="clearAnnotationsBtn" style="display: none;"><i class="fa-solid fa-trash-can"></i> Clear</button>
                <div id="annotationChannelSelector" style="display: flex; align-items: center; gap: 5px; margin-left: 10px; border-left: 1px solid #555; padding-left: 16px;"></div>
                <button class="tool-button" id="aboutBtn" style="margin-left: auto;"><i class="fas fa-info-circle"></i> About</button>
            </div>
            <div class="display-area" id="displayArea"><div class="waveform-container" id="waveformContainer"><canvas id="waveformCanvas"></canvas></div></div>
        </div>
    </div>
    <div class="status-bar">
        <div class="window-title">Advanced WFM Viewer</div>
        <div id="statusText" style="flex: 1;">Ready to load file</div>
        <div>Viewer v23.1</div>
    </div>

    <div class="modal-overlay" id="aboutModal">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2>About WFM Viewer</h2>
            <p>Created by: <b>Ali Nezarati</b>.</p>
            <p id="aboutDate"></p>
            <h3>Shortcuts</h3>
            <ul class="shortcut-list">
                <li><span>Fit Y-Axis (Channel or All)</span><code>F Key</code></li>
                <li><span>Full Reset View</span><code>Double Click</code></li>
                <li><span>Toggle Area Zoom Mode (1-time use)</span><code>Z Key</code></li>
                <li><span>Hide/Show Annotations</span><code>Ctrl + H</code></li>
                <li><span>Select Annotation Scale (Nth Channel)</span><code>1 - 9 Keys</code></li>
                <li><span>Paste Data from Clipboard</span><code>Ctrl + V</code></li>
                <li><span>Move Channel (Y-Axis)</span><code>Mouse Drag (on trace)</code></li>
                <li><span>Zoom (X-Axis)</span><code>Scroll over Chart</code></li>
                <li><span>Zoom (Y-Axis)</span><code>Scroll over Channel's Y-Axis</code></li>
                <li><span>Copy to Clipboard (PNG)</span><code>Ctrl + C</code></li>
                <li><span>Add Text Annotation</span><code>T Key</code></li>
                <li><span>Add Point Annotation</span><code>P Key</code></li>
                <li><span>Measure / Annotate area</span><code>Shift + Drag</code></li>
                <li><span>Delete Annotation</span><code>Click to Select + Delete Key</code></li>
            </ul>
        </div>
    </div>

    <div class="modal-overlay" id="exportModal">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2>Export Waveform</h2>
             <div class="export-options-container" style="display: flex; flex-direction: column; gap: 20px;">
                  <div>
                      <h3 style="margin-bottom: 8px;">Content</h3>
                      <label style="margin-right: 15px;"><input type="radio" name="content" value="current" checked> Current View</label>
                      <label><input type="radio" name="content" value="all"> All Data</label>
                  </div>
                  <div>
                      <h3 style="margin-bottom: 8px;">Format</h3>
                      <label style="margin-right: 15px;"><input type="radio" name="format" value="png" checked> PNG</label>
                      <label style="margin-right: 15px;"><input type="radio" name="format" value="svg"> SVG</label>
                      <label><input type="radio" name="format" value="csv"> CSV</label>
                  </div>
                  <div>
                      <h3 style="margin-bottom: 8px;">Include & Style</h3>
                      <label style="margin-right: 15px;"><input type="checkbox" id="exportStatsCheckbox" checked> Measurements</label>
                      <label style="margin-right: 15px;"><input type="checkbox" id="exportCursorsCheckbox" checked> Cursors</label>
                      <label style="margin-right: 15px;"><input type="checkbox" id="exportAnnotationsCheckbox" checked> Annotations</label>
                      <label style="margin-right: 15px;"><input type="checkbox" id="wbExportCheckbox"> White Background</label>
                      <br><br>
                      <label><input type="checkbox" id="exportTableBottomCheckbox"> Place measurements at bottom</label>
                  </div>
                  <div>
                      <label><input type="checkbox" id="ieeeStyleCheckbox"> <b>Use IEEE Style (Publication)</b></label>
                      <div class="ieee-options">
                          <p>Font: Times New Roman, 10pt<br>Background: White</p>
                          <div class="control-item" style="margin-top: 15px; margin-bottom: 5px;">
                              <label for="ieeeWidth" class="control-label">Width (inches):</label>
                              <input type="number" id="ieeeWidth" value="3.45" step="0.05" class="control-input" style="pointer-events: auto; font-family: 'Segoe UI', sans-serif;">
                          </div>
                          <div class="control-item">
                              <label for="ieeeHeight" class="control-label">Height (inches):</label>
                              <input type="number" id="ieeeHeight" value="2.5" step="0.05" class="control-input" style="pointer-events: auto; font-family: 'Segoe UI', sans-serif;">
                          </div>
                      </div>
                  </div>
             </div>
            <div class="modal-footer">
                <button class="modal-button modal-confirm-btn" id="exportConfirmBtn">Export</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="csvOptionsModal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="modal-close">&times;</span>
            <h2>CSV Import Options</h2>
            <p id="csvOptionsFileName" style="color: #ccc; margin-bottom: 15px;"></p>
            
            <div class="panel-title" style="font-size: 14px; margin-bottom: 5px;">File Preview</div>
            <pre id="csvPreviewContent" style="background: #2d2d2d; border: 1px solid #555; padding: 10px; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: Consolas, monospace; font-size: 12px; white-space: pre;"></pre>

            <div class="panel-title" style="font-size: 14px; margin-top: 20px; margin-bottom: 10px;">Parsing Options</div>
            <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 20px;">
                <div class="control-item" style="margin-bottom: 0;">
                    <span class="control-label">Delimiter:</span>
                    <input type="text" id="csvDelimiter" value="," class="control-input" style="width: 50px;">
                </div>
                <div class="checkbox-item" style="margin-top: 0;">
                    <label for="csvHasHeader"><input type="checkbox" id="csvHasHeader" checked> First row is header</label>
                </div>
            </div>

            <div class="panel-title" style="font-size: 14px; margin-bottom: 10px;">Column Roles</div>
            <div id="csvColumnMapping" style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto; padding-right: 10px;">
                </div>

            <div class="modal-footer">
                <button class="modal-button modal-cancel-btn">Cancel</button>
                <button class="modal-button modal-confirm-btn" id="csvOptionsConfirm">Load CSV</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="pastedDataOptionsModal">
        <div class="modal-content">
          <span class="modal-close">&times;</span>
          <h2>Pasted Data Options</h2>
          <p style="margin: 15px 0;">Single row/column of data detected. Please define the X-axis.</p>
          <div class="control-item">
            <label for="pasteTimeStart" class="control-label">Time Start:</label>
            <input type="text" id="pasteTimeStart" value="0" class="control-input">
          </div>
          <div class="control-item">
            <label for="pasteTimeStep" class="control-label">Time Step:</label>
            <input type="text" id="pasteTimeStep" value="1" class="control-input">
          </div>
          <div class="modal-footer">
            <button class="modal-button modal-cancel-btn">Cancel</button>
            <button class="modal-button modal-confirm-btn" id="pasteConfirmBtn">Load Data</button>
          </div>
        </div>
    </div>

    <div class="modal-overlay" id="pasteDestinationModal">
        <div class="modal-content">
          <span class="modal-close">&times;</span>
          <h2>Paste Data</h2>
          <p style="margin: 15px 0;">Where would you like to add the pasted waveform data?</p>
          <div class="modal-footer" style="justify-content: space-between;">
            <button class="modal-button modal-cancel-btn">Cancel</button>
            <div>
                <button class="modal-button modal-confirm-btn" id="pasteToCurrentBtn">Add to Current Tab</button>
                <button class="modal-button modal-confirm-btn" id="pasteToNewBtn">Create New Tab</button>
            </div>
          </div>
        </div>
    </div>

    <div id="drag-overlay">
        <div class="drag-overlay-content">
            <i class="fas fa-file-import"></i>
            <span>Drop WFM, CSV, or GRAPHX file(s) here</span>
        </div>
    </div>

<script>
    // --- PARSER FOR TEKTRONIX WFM FILES ---
    class TekWfmParser {
        constructor(arrayBuffer) {
            this.buffer = arrayBuffer;
            this.view = new DataView(this.buffer);
            const byteOrder = this.view.getUint16(0, false);
            this.littleEndian = (byteOrder === 0x0F0F);
        }
        getUint8(o) { return this.view.getUint8(o); }
        getInt16(o) { return this.view.getInt16(o, this.littleEndian); }
        getInt32(o) { return this.view.getInt32(o, this.littleEndian); }
        getUint32(o) { return this.view.getUint32(o, this.littleEndian); }
        getFloat64(o) { return this.view.getFloat64(o, this.littleEndian); }
        getString(o, l) {
            let s = '';
            for (let i = 0; i < l; i++) {
                const c = this.getUint8(o + i);
                if (c === 0) break;
                s += String.fromCharCode(c);
            }
            return s;
        }
        isValid() { return this.getString(2, 8).startsWith(':WFM#00'); }
        getTimeScale() { return this.getFloat64(478); }
        getNumDataPoints() { return this.getUint32(494); }
        getVoltageUnits() { return this.getString(186, 20); }
        getUserVoltsPerDiv() { return this.getFloat64(266); }
        getUserVerticalOffset() { return this.getFloat64(294); }
        isChannelWritten(ch) { return ch === 1; }
        getChannelData(ch) {
            if (ch !== 1) return null;
            const n = this.getNumDataPoints(), vS = this.getFloat64(166), vO = this.getFloat64(174);
            const dSO = this.getInt32(16), bPP = parseInt(this.getString(15, 1)), fmt = this.getInt32(238);
            if (fmt !== 0 || bPP !== 2) throw new Error("Unsupported WFM data format (must be 16-bit integer).");
            if (dSO + n * bPP > this.buffer.byteLength) return null;
            const d = new Float32Array(n);
            for (let i = 0; i < n; i++) d[i] = (this.getInt16(dSO + i * bPP) * vS) + vO;
            return d;
        }
    }

    // --- PARSER FOR RIGOL WFM FILES ---
    class RigolWfmParser {
        constructor(arrayBuffer) {
            this.buffer = arrayBuffer;
            this.view = new DataView(this.buffer);
            this.littleEndian = true;
            this.vScaOff = [0, 36, 60, 84, 108]; this.vOffOff = [0, 40, 64, 88, 112]; this.cWrtOff = [0, 49, 73, 97, 121];
        }
        getUint8(o) { return this.view.getUint8(o); }
        getInt16(o) { return this.view.getInt16(o, this.littleEndian); }
        getUint32(o) { return this.view.getUint32(o, this.littleEndian); }
        getFloat32(o) { return this.view.getFloat32(o, this.littleEndian); }
        getBigUint64(o) { return this.view.getBigUint64(o, this.littleEndian); }
        isValid() { return this.view.getUint16(0, true) === 0xA5A5; }
        getNumDataPoints() { return this.getUint32(28); }
        isChannelWritten(c) { return c > 0 && c <= 4 && this.cWrtOff[c] < this.view.byteLength && this.getUint8(this.cWrtOff[c]) !== 0; }
        getTimeScale() { return 1 / this.getSamplingFrequency(); }
        getSamplingFrequency() { return this.getFloat32(100); }
        getVoltageUnits() { return 'V'; }
        getVoltageScale(c) { return c > 0 && c <= 4 ? this.getUint32(this.vScaOff[c]) * 1e-6 : 0; }
        getVoltageOffset(c) {
            if (!this.isChannelWritten(c)) return 0;
            const rawPos = this.getInt16(this.vOffOff[c]);
            return -(rawPos / 25.0) * this.getVoltageScale(c) * 4;
        }
        getChannelData(c, vpd_override) {
            if (!this.isChannelWritten(c)) return null;
            const n = this.getNumDataPoints();
            const vPD = vpd_override || this.getVoltageScale(c);
            const iOff = -(this.getInt16(this.vOffOff[c]) / 25.0) * vPD * 4;
            const dSO = 272;
            let cDO = 0; for (let i = 1; i < c; i++) { if (this.isChannelWritten(i)) cDO += n; }
            const tO = dSO + cDO;
            if (tO + n > this.buffer.byteLength) return null;
            const d = new Float32Array(n);
            for (let i = 0; i < n; i++) d[i] = (125 - this.getUint8(tO + i)) / 25.0 * vPD + iOff;
            return d;
        }
    }

    // --- PARSER FOR CSV FILES ---
    class CsvParser {
        constructor(csvText, options) {
            this.timeData = [];
            this.channelData = {};
            this.channelNames = [];
            this.timePerPoint = 0;
            this.numPoints = 0;
            this.error = null;

            try {
                this._parse(csvText, options);
            } catch (e) {
                this.error = e.message;
                console.error("CSV Parsing Error:", e);
            }
        }

        _parse(csvText, options) {
            const { delimiter, hasHeader, timeColumnIndex, dataColumnIndices, autoTime } = options;
            const lines = csvText.replace(/\r/g, '').split('\n').filter(line => line.trim() !== '');

            if (lines.length < (hasHeader ? 2 : 1)) {
                throw new Error("CSV must have at least one data row.");
            }

            const startRow = hasHeader ? 1 : 0;
            const headers = hasHeader ? lines[0].split(delimiter).map(h => h.trim().replace(/^"|"$/g, '')) : [];

            if (dataColumnIndices.length === 0) {
                throw new Error("No data columns selected for import.");
            }
            
            // Determine channel names
            dataColumnIndices.forEach((colIndex, i) => {
                const name = (hasHeader && headers[colIndex]) ? headers[colIndex] : `f(x) ${dataColumnIndices.length > 1 ? (i + 1) : ''}`.trim();
                this.channelNames.push(name);
                this.channelData[name] = [];
            });

            // Parse data rows
            for (let i = startRow; i < lines.length; i++) {
                const values = lines[i].split(delimiter).map(v => v.trim().replace(/^"|"$/g, ''));
                
                // Time data
                if (autoTime) {
                    this.timeData.push(i - startRow); // Simple index as time
                } else {
                    const timeVal = parseFloat(values[timeColumnIndex]);
                    if (isNaN(timeVal)) continue; // Skip rows with invalid time data
                    this.timeData.push(timeVal);
                }
                
                // Channel data
                dataColumnIndices.forEach((colIndex, chIndex) => {
                    const chName = this.channelNames[chIndex];
                    const val = parseFloat(values[colIndex]);
                    this.channelData[chName].push(isNaN(val) ? 0 : val);
                });
            }
            
            if (this.timeData.length < 2) {
                throw new Error("Not enough valid data points in CSV to process.");
            }
            
            this.numPoints = this.timeData.length;
            this.timePerPoint = autoTime ? 1 : (this.timeData[1] - this.timeData[0]);

            // Convert to Float32Array
            for (const name of this.channelNames) {
                this.channelData[name] = new Float32Array(this.channelData[name]);
            }
        }
        
        isValid() { return !this.error && this.numPoints > 0; }
        getTimeScale() { return this.timePerPoint; }
        getNumDataPoints() { return this.numPoints; }
        getVoltageUnits(chName) { 
             const match = chName.match(/\((.*?)\)/);
             return match ? match[1] : 'V';
        }
        getChannelData(chName) { return this.channelData[chName] || null; }
    }

    // --- DUMMY PARSER FOR PASTED DATA ---
    class PastedDataParser {
        constructor(dataArray, options) {
            this.data = new Float32Array(dataArray);
            this.timePerPoint = options.step;
            this.timeStart = options.start;
        }
        isValid() { return true; }
        getTimeScale() { return this.timePerPoint; }
        getNumDataPoints() { return this.data.length; }
        getVoltageUnits() { return 'V'; }
        getChannelNames() { return ['Pasted Data']; } // For multi-channel support in merger
        getChannelData(chName) { return this.data; }
    }

    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('waveformCanvas');
        const ctx = canvas.getContext('2d');
        const tabContainer = document.getElementById('tabContainer');
        const dragOverlay = document.getElementById('drag-overlay');
        const statusText = document.getElementById('statusText');
        const csvOptionsModal = document.getElementById('csvOptionsModal');
        const pastedDataOptionsModal = document.getElementById('pastedDataOptionsModal');
        let tempCsvData = { text: '', fileName: '' };
        let tempPastedData = null;

        let tabStates = [];
        let activeTabIndex = -1;
        let isDraggingFile = false;
        
        let isPanning = false, zoomModeEnabled = false;
        let panStart = { x: 0, y: 0, viewStart: 0, viewEnd: 0, vRanges: {} };
        let dragStart = { x: 0, y: 0 }, dragEnd = { x: 0, y: 0 };
        let activeInteraction = { type: null, index: -1, handle: null, channel: null };
        let displayOptions = { showStats: true, discreteZoom: false, relativeTime: false, separateView: false };
        let textAnnotationMode = false;
        let pointAnnotationMode = false;
        let lastMousePos = { x: 0, y: 0 };
        let hoveredChannelInfo = null;
        let lastHoveredChannelId = null;

        const X_DIVS = 10;
        const Y_DIVS = 10;
        const Y_DIVS_SEPARATE = 4;
        const PADDING_STATIC = { top: 30, right: 40, bottom: 60 };
        const Y_AXIS_WIDTH = 70;
        const Y_AXIS_WIDTH_SEPARATE = 55;
        const SEPARATE_VIEW_GAP = 20;
        const OVERLAP_COLORS = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94'];

        function createDefaultTabState(fileName, parser, overrides = {}) {
            const timePerPoint = parser.getTimeScale();
            const numPoints = parser.getNumDataPoints();
            
            const newState = {
                fileName: fileName,
                parser: parser,
                waveforms: {},
                metadata: { timePerPoint: timePerPoint, totalTime: numPoints * timePerPoint, numPoints: numPoints },
                channelInfo: {},
                drawOrder: [],
                view: { startIndex: 0, endIndex: numPoints },
                cursors: { enabled: false, x1: null, x2: null, y1: null, y2: null, trackingChannel: null },
                annotations: [], textAnnotations: [], pointAnnotations: [], annotationMode: false,
                annotationsVisible: true,
                annotationChannel: null,
                isOverlap: false,
            };

            if (parser instanceof PastedDataParser) {
                const data = parser.getChannelData();
                let min = Infinity, max = -Infinity;
                for(const v of data) {
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
                const margin = (max - min) * 0.1 || 1;
                const chName = 'Pasted Data';
                newState.waveforms[chName] = data;
                newState.drawOrder.push(chName);
                newState.channelInfo[chName] = {
                    name: chName, visible: true, color: OVERLAP_COLORS[0], units: parser.getVoltageUnits(),
                    vMin: min - margin, vMax: max + margin
                };
                newState.metadata.timeStart = overrides.start || 0;
            } else if (parser instanceof CsvParser) {
                let colorIdx = 0;
                parser.channelNames.forEach(chName => {
                    const data = parser.getChannelData(chName);
                    if (data) {
                        let min = Infinity, max = -Infinity;
                        for(const v of data) {
                            if (v < min) min = v;
                            if (v > max) max = v;
                        }
                        const margin = (max - min) * 0.1 || 1;

                        newState.waveforms[chName] = data;
                        newState.drawOrder.push(chName);
                        newState.channelInfo[chName] = {
                            name: chName, visible: true, color: OVERLAP_COLORS[colorIdx % OVERLAP_COLORS.length], units: parser.getVoltageUnits(chName),
                            vMin: min - margin, vMax: max + margin
                        };
                        colorIdx++;
                    }
                });
            } else if (parser instanceof TekWfmParser) {
                const data = parser.getChannelData(1);
                const userVoltsPerDiv = parser.getUserVoltsPerDiv();
                const userVertOffsetDivs = parser.getUserVerticalOffset();
                const vSpan = userVoltsPerDiv * Y_DIVS;
                const vCenter = -userVertOffsetDivs * userVoltsPerDiv;
                
                newState.waveforms['channel1'] = data;
                newState.drawOrder.push('channel1');
                newState.channelInfo['channel1'] = {
                    name: 'Channel 1', visible: true, color: OVERLAP_COLORS[0], units: parser.getVoltageUnits(),
                    vMin: vCenter - vSpan / 2, vMax: vCenter + vSpan / 2
                };
            } else if (parser instanceof RigolWfmParser) {
                let colorIdx = 0;
                for (let i = 1; i <= 4; i++) {
                    if (parser.isChannelWritten(i)) {
                        const chKey = `channel${i}`;
                        const multiplier = overrides[chKey]?.multiplier || 1;
                        const voltsPerDiv = parser.getVoltageScale(i) * multiplier;
                        const data = parser.getChannelData(i, voltsPerDiv);
                        
                        if(data) {
                            const voltageOffset = -(parser.getInt16(parser.vOffOff[i]) / 25.0) * voltsPerDiv * 4;
                            const vSpan = voltsPerDiv * 8; // Rigol screen has 8 vertical divisions

                            newState.waveforms[chKey] = data;
                            newState.drawOrder.push(chKey);
                            newState.channelInfo[chKey] = {
                                name: `Channel ${i}`, visible: true, color: OVERLAP_COLORS[colorIdx % OVERLAP_COLORS.length], units: 'V',
                                vMin: voltageOffset - vSpan / 2, vMax: voltageOffset + vSpan / 2
                            };
                            colorIdx++;
                        }
                    }
                }
            }
            if (newState.drawOrder.length > 0) {
                newState.annotationChannel = newState.drawOrder[0];
            }
            return newState;
        }
        function getActiveState() { return activeTabIndex > -1 ? tabStates[activeTabIndex] : null; }
        
        function parseEng(str) { if (typeof str !== 'string' || !str) return NaN; const suffixes = { f: 1e-15, p: 1e-12, n: 1e-9, u: 1e-6, µ: 1e-6, m: 1e-3, k: 1e3, K: 1e3, M: 1e6, G: 1e9, T: 1e12 }; str = str.trim(); const numPart = parseFloat(str); if (isNaN(numPart)) return NaN; const suffixMatch = str.match(/[a-zA-Zµ]+$/); const suffix = suffixMatch ? suffixMatch[0] : null; const multiplier = suffixes[suffix] || 1; return numPart * multiplier; }
        function getVisibleChannels(state) {
            if (!state) return [];
            return state.drawOrder.filter(ch => state.channelInfo[ch] && state.channelInfo[ch].visible && state.waveforms[ch]);
        }
        function getDynamicPadding(state) {
            if (!state) return { ...PADDING_STATIC, left: Y_AXIS_WIDTH + 10 };
            const visibleChannels = getVisibleChannels(state);
            if (visibleChannels.length === 0) return { ...PADDING_STATIC, left: Y_AXIS_WIDTH + 10 };
            
            if (displayOptions.separateView && !state.isOverlap) {
                return { ...PADDING_STATIC, left: Y_AXIS_WIDTH_SEPARATE + 10 };
            } else {
                const left = Y_AXIS_WIDTH * visibleChannels.length + 10;
                return { ...PADDING_STATIC, left: Math.max(Y_AXIS_WIDTH + 10, left) };
            }
        }
        function getPlotArea(width, height, state) {
            const PADDING = getDynamicPadding(state);
            return { x: PADDING.left, y: PADDING.top, width: width - PADDING.left - PADDING.right, height: height - PADDING.top - PADDING.bottom };
        }
        function screenToData(screenPos, view, state, channelId, plotArea) {
            const { width, height } = canvas.getBoundingClientRect();
            const p = plotArea || getPlotArea(width, height, state);
            if (!view || !state || !p.width || !p.height) return {time: 0, voltage: 0};
            
            const targetChannelId = channelId || (getVisibleChannels(state)[0]);
            let voltage = 0;
            if (targetChannelId && state.channelInfo[targetChannelId]) {
                 const chInfo = state.channelInfo[targetChannelId];
                 voltage = chInfo.vMax - (screenPos.y - p.y) * (chInfo.vMax - chInfo.vMin) / p.height;
            }
            const timeOffset = state.metadata.timeStart || 0;
            const time = (screenPos.x - p.x) * ((view.endIndex - view.startIndex) * state.metadata.timePerPoint) / p.width + (view.startIndex * state.metadata.timePerPoint);
            return { time: time + timeOffset, voltage };
        }
        function dataToScreen(dataPos, view, state, channelId, plotArea) {
            const { width, height } = canvas.getBoundingClientRect();
            const p = plotArea || getPlotArea(width, height, state);
            if (!view || !state || !channelId || !state.channelInfo[channelId] || !p.width || !p.height) return {x: 0, y: 0};
            
            const chInfo = state.channelInfo[channelId];
            const viewTimeSpan = (view.endIndex - view.startIndex) * state.metadata.timePerPoint;
            const viewVoltSpan = chInfo.vMax - chInfo.vMin;
            if (viewTimeSpan <= 0 || viewVoltSpan <= 0) return {x: p.x, y: p.y + p.height / 2};
            
            const timeOffset = state.metadata.timeStart || 0;
            const viewStartTime = (view.startIndex * state.metadata.timePerPoint);

            return {
                x: p.x + ((dataPos.time - timeOffset - viewStartTime) / viewTimeSpan) * p.width,
                y: p.y + ((chInfo.vMax - dataPos.voltage) / viewVoltSpan) * p.height
            };
        }

        function resizeCanvas() { const dpr = window.devicePixelRatio || 1; const rect = document.getElementById('waveformContainer').getBoundingClientRect(); canvas.width = rect.width * dpr; canvas.height = rect.height * dpr; ctx.scale(dpr, dpr); draw(); }

        function draw() {
            requestAnimationFrame(() => {
                const state = getActiveState();
                const colors = {
                    bg: '#1e1e1e',
                    grid: '#333',
                    text: '#a0a0a0',
                    axisBorder: '#888',
                    cursorTime: '#f0ad4e',
                    cursorVolt: '#32f0ad',
                    selection: '#00bcf2'
                };
                drawToContext(ctx, state, colors);
            });
        }
        
        function drawToContext(context, state, colors) {
                const { width, height } = canvas.getBoundingClientRect();
                context.fillStyle = colors.bg;
                context.fillRect(0, 0, width, height);
                
                if (!state || Object.keys(state.waveforms).length === 0) {
                    const plotArea = getPlotArea(width, height, null);
                    drawGrid(context, plotArea, colors);
                    drawPlaceholder(context, plotArea, colors);
                    drawAxisLabels(context, plotArea, null, null, null, colors);
                    return;
                }
                
                const visibleChannels = getVisibleChannels(state);

                if (displayOptions.separateView && !state.isOverlap && visibleChannels.length > 0) {
                    const PADDING = getDynamicPadding(state);
                    const totalPlotHeight = height - PADDING.top - PADDING.bottom;
                    const totalGapHeight = (visibleChannels.length > 1) ? (visibleChannels.length - 1) * SEPARATE_VIEW_GAP : 0;
                    const individualPlotHeight = (totalPlotHeight - totalGapHeight) / visibleChannels.length;

                    if (individualPlotHeight > 0) {
                        visibleChannels.forEach((ch, index) => {
                            const plotArea = {
                                x: PADDING.left,
                                y: PADDING.top + index * (individualPlotHeight + SEPARATE_VIEW_GAP),
                                width: width - PADDING.left - PADDING.right,
                                height: individualPlotHeight
                            };

                            drawGrid(context, plotArea, colors, true, index === visibleChannels.length - 1);
                            drawAxisLabels(context, plotArea, state.view, state, ch, colors);

                            context.save();
                            context.rect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
                            context.clip();
                            drawWaveform(context, state, ch, plotArea, colors);
                            if (state.cursors.enabled) drawCursors(context, plotArea, state, colors);
                            drawAnnotations(context, state.view, plotArea, state, colors);
                            drawTextAnnotations(context, state.view, plotArea, state, colors);
                            drawPointAnnotations(context, state.view, plotArea, state, colors);
                            context.restore();

                            context.strokeStyle = colors.axisBorder; context.lineWidth = 1;
                            context.strokeRect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
                        });
                    }
                } else {
                    const plotArea = getPlotArea(width, height, state);
                    drawGrid(context, plotArea, colors, false, true);
                    drawAxisLabels(context, plotArea, state.view, state, null, colors);
                    
                    context.save();
                    context.rect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
                    context.clip();
                    
                    state.drawOrder.forEach(ch => { 
                        if (state.channelInfo[ch] && state.channelInfo[ch].visible && state.waveforms[ch]) {
                            drawWaveform(context, state, ch, plotArea, colors);
                        }
                    });
                    
                    if (state.cursors.enabled) drawCursors(context, plotArea, state, colors);
                    drawAnnotations(context, state.view, plotArea, state, colors);
                    drawTextAnnotations(context, state.view, plotArea, state, colors);
                    drawPointAnnotations(context, state.view, plotArea, state, colors);
                    context.restore();
                    
                    context.strokeStyle = colors.axisBorder; context.lineWidth = 1;
                    context.strokeRect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
                    if (displayOptions.showStats) drawStats(context, plotArea, state, colors);
                }
                
                if (context === ctx) {
                    if (activeInteraction.type === 'zoom-drag' || activeInteraction.type === 'measure-drag') {
                        drawDragRectangle();
                        if (activeInteraction.type === 'measure-drag') {
                            drawLiveMeasurementBox(state);
                        }
                    }
                     if (hoveredChannelInfo) {
                         drawHoverTooltip();
                     }
                }
        }
        
        function drawLiveMeasurementBox(state) {
            const w = Math.abs(dragStart.x - dragEnd.x), h = Math.abs(dragStart.y - dragEnd.y);
            if (w < 5 || h < 5) return;

            const { width, height } = canvas.getBoundingClientRect();
            let p_area = null;
            const dragRefCh = state.annotationChannel || getVisibleChannels(state)[0];
            const visibleChannels = getVisibleChannels(state);

            if (displayOptions.separateView && visibleChannels.length > 0 && !state.isOverlap) {
                const PADDING = getDynamicPadding(state);
                const totalPlotHeight = height - PADDING.top - PADDING.bottom;
                const totalGapHeight = (visibleChannels.length > 1) ? (visibleChannels.length - 1) * SEPARATE_VIEW_GAP : 0;
                const individualPlotHeight = (totalPlotHeight - totalGapHeight) / visibleChannels.length;
                if (individualPlotHeight > 0) {
                    const blockHeight = individualPlotHeight + SEPARATE_VIEW_GAP;
                    const relativeY = dragStart.y - PADDING.top;
                    const blockIndex = Math.max(0, Math.floor(relativeY / blockHeight));
                    
                    if (blockIndex < visibleChannels.length) {
                        p_area = {
                            x: PADDING.left,
                            y: PADDING.top + blockIndex * blockHeight,
                            width: width - PADDING.left - PADDING.right,
                            height: individualPlotHeight
                        };
                    }
                }
            } else {
                p_area = getPlotArea(width, height, state);
            }

            if (dragRefCh && p_area) {
                const chInfo = state.channelInfo[dragRefCh];
                const { time: t_start, voltage: v_start } = screenToData({ x: dragStart.x, y: dragStart.y }, state.view, state, dragRefCh, p_area);
                const { time: t_end, voltage: v_end } = screenToData({ x: dragEnd.x, y: dragEnd.y }, state.view, state, dragRefCh, p_area);
                const dt = Math.abs(t_end - t_start), dV = Math.abs(v_end - v_start), freq = dt > 0 ? 1 / dt : 0;
                
                const bgColor = hexToRgba(chInfo.color, 0.2), textColor = chInfo.color;
                const text1 = `Δt: ${formatEng(dt, 's')}`, text2 = `1/Δt: ${formatEng(freq, 'Hz')}`, text3 = `ΔV: ${formatEng(dV, chInfo.units)}`;
                
                ctx.font = '13px Segoe UI';
                const boxWidth = Math.max(ctx.measureText(text1).width, ctx.measureText(text2).width, ctx.measureText(text3).width) + 20;
                const boxHeight = 70;
                let boxX = Math.max(dragStart.x, dragEnd.x) + 10, boxY = dragEnd.y - boxHeight / 2;

                if (boxX + boxWidth > width) { boxX = Math.min(dragStart.x, dragEnd.x) - boxWidth - 10; }
                if (boxY < 0) { boxY = 5; }
                if (boxY + boxHeight > height) { boxY = height - boxHeight - 5; }

                ctx.fillStyle = bgColor; ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.fillStyle = textColor; ctx.font = ` 13px Segoe UI`; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                ctx.fillText(text1, boxX + 10, boxY + 5);
                ctx.fillText(text2, boxX + 10, boxY + 25);
                ctx.fillText(text3, boxX + 10, boxY + 45);
            }
        }

        function drawHoverTooltip() {
            if (!hoveredChannelInfo) return;
            const { name, color, x, y } = hoveredChannelInfo;
            const padding = 8;
            ctx.font = '13px Segoe UI';
            const textWidth = ctx.measureText(name).width;
            const boxWidth = textWidth + 2 * padding;
            const boxHeight = 28;
            let boxX = x + 15, boxY = y + 15;
            const canvasRect = canvas.getBoundingClientRect();
            if (boxX + boxWidth > canvasRect.width) { boxX = x - boxWidth - 15; }
            if (boxY + boxHeight > canvasRect.height) { boxY = y - boxHeight - 15; }
            ctx.fillStyle = 'rgba(40, 40, 40, 0.85)';
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(name, boxX + padding, boxY + boxHeight / 2);
        }
        
               function formatEng(v, u, p = 3, includeUnit = true){ 
            if(isNaN(v) || v === null) return `- ${includeUnit && u ? u : ''}`.trim(); 
            const s = v < 0 ? '-' : ''; 
            v = Math.abs(v); 
            if (v === 0) return `0 ${includeUnit && u ? u : ''}`.trim(); 
            const k = ['f', 'p', 'n', 'µ', 'm', '', 'k', 'M', 'G', 'T']; 
            const i = Math.floor((Math.log10(v) || 0) / 3); 
            const d = v / 10**(i * 3); 
            return (s + d.toPrecision(p) + (k[i + 5] || '') + (includeUnit && u ? ` ${u}` : '')).trim(); 
        }
        function drawGrid(context, p, colors, isSeparate=false, isLast=true){context.strokeStyle=colors.grid;context.lineWidth=1;for(let i=0;i<=X_DIVS;i++){const x=p.x+i/X_DIVS*p.width;context.beginPath();context.moveTo(x,p.y);context.lineTo(x,p.y+p.height);context.stroke()} const yDivs = (isSeparate || (displayOptions.separateView && !getActiveState()?.isOverlap)) ? Y_DIVS_SEPARATE : Y_DIVS; for(let i=0;i<=yDivs;i++){const y=p.y+i/yDivs*p.height;if(isSeparate && i===yDivs && !isLast) continue;context.beginPath();context.moveTo(p.x,y);context.lineTo(p.x+p.width,y);context.stroke()}}
        
        function drawAxisLabels(context, p, view, state, separateChannelId = null, colors){
            context.fillStyle=colors.text; 
            context.font='14px Segoe UI'; 
            context.textAlign='center';
            context.textBaseline='top';
            if (view && state) { 
                const timeOffset = state.metadata.timeStart || 0;
                const timeSpan = (view.endIndex - view.startIndex) * state.metadata.timePerPoint;
                if(timeSpan > 0){
                    const tStart = (view.startIndex * state.metadata.timePerPoint) + timeOffset;
                    for(let i=0; i<=X_DIVS; i++){
                        const x = p.x + i/X_DIVS*p.width;
                        const timeVal = displayOptions.relativeTime ? (i/X_DIVS*timeSpan) : (tStart + i/X_DIVS*timeSpan);
                        const isLastSeparateView = separateChannelId && getVisibleChannels(state).slice(-1)[0] === separateChannelId;
                        if (!displayOptions.separateView || state.isOverlap || isLastSeparateView) {
                             context.fillText(formatEng(timeVal, 's', 3, false), x, p.y + p.height + 10);
                        }
                    }
                }
            }
            const isLastSeparateViewForTitle = separateChannelId && getVisibleChannels(state)?.slice(-1)[0] === separateChannelId;
            if (!displayOptions.separateView || state?.isOverlap || isLastSeparateViewForTitle) {
                 context.fillText('Time (s)', p.x + p.width / 2, p.y + p.height + 35);
            }

            if (state) {
                const visibleChannels = separateChannelId ? [separateChannelId] : getVisibleChannels(state);
                const yDivs = separateChannelId ? Y_DIVS_SEPARATE : Y_DIVS;
                visibleChannels.forEach((chId, i) => {
                    const chInfo = state.channelInfo[chId];
                    if (!chInfo) return;
                    const vRange = chInfo.vMax - chInfo.vMin;
                    const axisWidth = (displayOptions.separateView && !state.isOverlap) ? Y_AXIS_WIDTH_SEPARATE : Y_AXIS_WIDTH;
                    const axisX = p.x - (i * axisWidth) - 10;
                    context.fillStyle = colors.bwTraces ? colors.text : chInfo.color;
                    context.textAlign = 'right';
                    context.textBaseline = 'middle';
                    if (vRange > 0) {
                        for(let j=0; j<=yDivs; j++){
                            const y = p.y + j/yDivs*p.height;
                            const v = chInfo.vMax - j/yDivs*vRange;
                            context.fillText(formatEng(v, '', 3, false), axisX, y);
                        }
                    }
                });

                context.save();
                context.fillStyle = colors.text;
                context.font = '16px Segoe UI';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.translate(20, p.y + p.height / 2);
                context.rotate(-Math.PI / 2);
                const firstChannelInfo = visibleChannels.length > 0 ? state.channelInfo[visibleChannels[0]] : null;
                const unit = firstChannelInfo ? firstChannelInfo.units : 'V';
                context.fillText(`Voltage (${unit})`, 0, 0);
                context.restore();
            }
        }

        function drawWaveform(context, state, ch, p, colors) {
            const voltageData = state.waveforms[ch];
            const chInfo = state.channelInfo[ch];
            const vRange = chInfo.vMax - chInfo.vMin;
            if (vRange <= 0) return;

            const dataTimePerPoint = chInfo.originalMetadata ? chInfo.originalMetadata.timePerPoint : state.metadata.timePerPoint;
            const dataNumPoints = chInfo.originalMetadata ? chInfo.originalMetadata.numPoints : state.metadata.numPoints;
            const timeOffset = state.metadata.timeStart || 0;
            const viewStartTime = (state.view.startIndex * state.metadata.timePerPoint);
            const viewEndTime = (state.view.endIndex * state.metadata.timePerPoint);
            const viewTimeSpan = viewEndTime - viewStartTime;
            if (viewTimeSpan <= 0) return;

            let traceColor = chInfo.color;
            if(colors.bwTraces) {
                const visibleChannels = getVisibleChannels(state);
                const colorIndex = visibleChannels.indexOf(ch);
                traceColor = colors.bwTraces[colorIndex % colors.bwTraces.length];
            }

            context.strokeStyle = traceColor;
            context.lineWidth = 1.5;
            context.beginPath();
            
            const startIndex = Math.max(0, Math.floor(viewStartTime / dataTimePerPoint));
            const endIndex = Math.min(dataNumPoints, Math.ceil(viewEndTime / dataTimePerPoint));
            const pointsInView = endIndex - startIndex;
            if (pointsInView <= 1) return;

            if (pointsInView > p.width * 2) { // Decimation
                const timeStepPerPixel = viewTimeSpan / p.width;
                 for (let i = 0; i < p.width; i++) {
                    const tStart = viewStartTime + i * timeStepPerPixel;
                    const tEnd = tStart + timeStepPerPixel;
                    const idxStart = Math.max(startIndex, Math.floor(tStart / dataTimePerPoint));
                    const idxEnd = Math.min(endIndex, Math.ceil(tEnd / dataTimePerPoint));
                    if (idxStart >= idxEnd) continue;
                    let min = Infinity, max = -Infinity;
                    for (let j = idxStart; j < idxEnd; j++) {
                        const v = voltageData[j];
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    if (min === Infinity) continue;
                    const x_px = p.x + i;
                    const y_min_px = p.y + ((chInfo.vMax - min) / vRange) * p.height;
                    const y_max_px = p.y + ((chInfo.vMax - max) / vRange) * p.height;
                    
                    if (i === 0) context.moveTo(x_px, y_max_px);
                    context.lineTo(x_px, y_max_px);
                    context.lineTo(x_px, y_min_px);
                }
            } else { // Direct drawing
                for (let i = startIndex; i < endIndex; i++) {
                    const dataTime = (i * dataTimePerPoint) + timeOffset;
                    const voltage = voltageData[i];
                    const x_px = p.x + ((dataTime - timeOffset - viewStartTime) / viewTimeSpan) * p.width;
                    const y_px = p.y + ((chInfo.vMax - voltage) / vRange) * p.height;
                    if (i === startIndex) context.moveTo(x_px, y_px);
                    else context.lineTo(x_px, y_px);
                }
            }
            context.stroke();
        }

        function drawPlaceholder(context, p, colors){context.fillStyle=colors.text;context.font='18px sans-serif';context.textAlign='center';context.fillText('No waveform loaded',p.x+p.width/2,p.y+p.height/2);context.fillText('Click "Load File", drop a file, or paste data (Ctrl+V)',p.x+p.width/2,p.y+p.height/2+30)}
        function drawDragRectangle(){ctx.fillStyle='rgba(0,120,215,0.3)';ctx.strokeStyle='#0078d7';ctx.lineWidth=1;const x=Math.min(dragStart.x,dragEnd.x),y=Math.min(dragStart.y,dragEnd.y),w=Math.abs(dragStart.x-dragEnd.x),h=Math.abs(dragStart.y-dragEnd.y);ctx.fillRect(x,y,w,h);ctx.strokeRect(x,y,w,h)}
        function drawStats(context, plotArea, state, colors) { if (!state || Object.keys(state.waveforms).length === 0) return; const visibleChannels = getVisibleChannels(state); if (visibleChannels.length === 0 || state.isOverlap) return; const activeMeasures = { max: document.getElementById('showMaxCheckbox').checked, min: document.getElementById('showMinCheckbox').checked, avg: document.getElementById('showAvgCheckbox').checked, rms: document.getElementById('showRmsCheckbox').checked }; const measureOrder = ['max', 'min', 'avg', 'rms']; const measureLabels = { max: 'Max', min: 'Min', avg: 'Avg', rms: 'RMS' }; const rows = measureOrder.filter(m => activeMeasures[m]); if (rows.length === 0) return; const allStats = {}; visibleChannels.forEach(ch => { allStats[ch] = calculateStats(state, ch); }); context.font = '13px Consolas, monospace'; context.textBaseline = 'middle'; const rowHeaders = rows.map(r => measureLabels[r]); const cellPadding = 10, lineHeight = 22; const colWidths = [0, ...visibleChannels.map(() => 0)]; colWidths[0] = Math.max(...rowHeaders.map(h => context.measureText(h).width)); rows.forEach(rowKey => { visibleChannels.forEach((ch, chIndex) => { const text = formatEng(allStats[ch][rowKey], state.channelInfo[ch].units, 3); colWidths[chIndex + 1] = Math.max(colWidths[chIndex + 1], context.measureText(text).width); }); }); for (let i = 0; i < colWidths.length; i++) { colWidths[i] += cellPadding * 2; } const tableWidth = colWidths.reduce((a, b) => a + b, 0); const tableHeight = rows.length * lineHeight + cellPadding; context.fillStyle = colors.statsBg || 'rgba(0,0,0,0.6)'; context.fillRect(plotArea.x + 10, plotArea.y + 10, tableWidth, tableHeight); context.strokeStyle = colors.grid; context.lineWidth = 1; context.strokeRect(plotArea.x + 10, plotArea.y + 10, tableWidth, tableHeight); let currentY = plotArea.y + 10 + lineHeight / 2 + cellPadding/2; rows.forEach((rowKey, rowIndex) => { let currentX = plotArea.x + 10; context.fillStyle = colors.text; context.textAlign = 'left'; context.fillText(rowHeaders[rowIndex], currentX + cellPadding, currentY); currentX += colWidths[0]; context.textAlign = 'right'; visibleChannels.forEach((ch, chIndex) => { const text = formatEng(allStats[ch][rowKey], state.channelInfo[ch].units, 3); context.fillStyle = colors.bwTraces ? colors.bwTraces[chIndex % colors.bwTraces.length] : state.channelInfo[ch].color; context.fillText(text, currentX + colWidths[chIndex + 1] - cellPadding, currentY); currentX += colWidths[chIndex + 1]; }); currentY += lineHeight; }); let currentX = plotArea.x + 10 + colWidths[0]; for(let i = 1; i < colWidths.length; i++) { context.beginPath(); context.moveTo(currentX, plotArea.y + 10); context.lineTo(currentX, plotArea.y + 10 + tableHeight); context.stroke(); currentX += colWidths[i]; } }
        function drawCursors(context, plotArea, state, colors) { const { view, cursors } = state; context.save(); context.setLineDash([6, 4]); context.lineWidth = 1.5; context.strokeStyle = colors.cursorTime; const refCh = getVisibleChannels(state)[0] || Object.keys(state.channelInfo)[0]; if(!refCh) { context.restore(); return; } const x1_s = dataToScreen({time: cursors.x1, voltage: 0}, view, state, refCh, plotArea).x, x2_s = dataToScreen({time: cursors.x2, voltage: 0}, view, state, refCh, plotArea).x; if (x1_s >= plotArea.x && x1_s <= plotArea.x + plotArea.width) { context.beginPath(); context.moveTo(x1_s, plotArea.y); context.lineTo(x1_s, plotArea.y + plotArea.height); context.stroke(); } if (x2_s >= plotArea.x && x2_s <= plotArea.x + plotArea.width) { context.beginPath(); context.moveTo(x2_s, plotArea.y); context.lineTo(x2_s, plotArea.y + plotArea.height); context.stroke(); } context.strokeStyle = colors.cursorVolt; const y1_s = dataToScreen({time: 0, voltage: cursors.y1}, view, state, refCh, plotArea).y, y2_s = dataToScreen({time: 0, voltage: cursors.y2}, view, state, refCh, plotArea).y; if (y1_s >= plotArea.y && y1_s <= plotArea.y + plotArea.height) { context.beginPath(); context.moveTo(plotArea.x, y1_s); context.lineTo(plotArea.x + plotArea.width, y1_s); context.stroke(); } if (y2_s >= plotArea.y && y2_s <= plotArea.y + plotArea.height) { context.beginPath(); context.moveTo(plotArea.x, y2_s); context.lineTo(plotArea.x + plotArea.width, y2_s); context.stroke(); } context.restore(); if(context === ctx) updateCursorReadouts(state); }
        function drawAnnotations(context, targetView, plotArea, state, colors) { 
            if (!state.annotationsVisible || !state.annotations) return;
            const handleSize = 8;
            const refCh = getVisibleChannels(state)[0]; 
            if(!refCh) return; 
            state.annotations.forEach((box, index) => { 
                const boxChannelId = box.channel || refCh;
                const chInfo = state.channelInfo[boxChannelId];
                if (!chInfo) return;

                const p1 = dataToScreen({time: box.t1, voltage: box.v1}, targetView, state, boxChannelId, plotArea);
                const p2 = dataToScreen({time: box.t2, voltage: box.v2}, targetView, state, boxChannelId, plotArea);
                const x = Math.min(p1.x, p2.x), y = Math.min(p1.y, p2.y), w = Math.abs(p1.x - p2.x), h = Math.abs(p1.y - p2.y); 

                const isSelected = activeInteraction.type === 'annotation' && activeInteraction.index === index; 
                let traceColor = chInfo.color;
                if(colors.bwTraces) {
                    const visibleChannels = getVisibleChannels(state);
                    const colorIndex = visibleChannels.indexOf(boxChannelId);
                    traceColor = colorIndex > -1 ? colors.bwTraces[colorIndex % colors.bwTraces.length] : colors.text;
                }
                
                context.strokeStyle = isSelected ? colors.selection : traceColor; 
                context.fillStyle = hexToRgba(traceColor, 0.08); 
                context.lineWidth = isSelected ? 2 : 1; 
                context.fillRect(x, y, w, h); 
                context.strokeRect(x, y, w, h); 

                if(box.text) {
                    context.font = '14px Segoe UI';
                    const textWidth = context.measureText(box.text).width;
                    context.fillStyle = colors.statsBg || 'rgba(0,0,0,0.6)';
                    context.fillRect(x, y - 22, textWidth + 10, 22);
                    context.fillStyle = isSelected ? colors.selection : traceColor;
                    context.textAlign = 'left';
                    context.textBaseline = 'middle';
                    context.fillText(box.text, x + 5, y - 11);
                }

                if(isSelected && context === ctx){ context.fillStyle = '#ffffff'; context.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize); context.fillRect(x + w - handleSize/2, y - handleSize/2, handleSize, handleSize); context.fillRect(x - handleSize/2, y + h - handleSize/2, handleSize, handleSize); context.fillRect(x + w - handleSize/2, y + h - handleSize/2, handleSize, handleSize); } }); 
        }
        function drawTextAnnotations(context, targetView, plotArea, state, colors) { 
            if (!state.annotationsVisible || !state.textAnnotations) return;
            state.textAnnotations.forEach((ann, index) => {
                const annChannel = ann.channel || getVisibleChannels(state)[0];
                if(!annChannel) return;
                let traceColor = state.channelInfo[annChannel] ? state.channelInfo[annChannel].color : colors.text;
                 if(colors.bwTraces) {
                    const visibleChannels = getVisibleChannels(state);
                    const colorIndex = visibleChannels.indexOf(annChannel);
                    traceColor = colorIndex > -1 ? colors.bwTraces[colorIndex % colors.bwTraces.length] : colors.text;
                }
                
                const pos = dataToScreen({time: ann.time, voltage: ann.voltage}, targetView, state, annChannel, plotArea);
                const isSelected = activeInteraction.type === 'textAnnotation' && activeInteraction.index === index;
                context.font = '14px Segoe UI';
                const textWidth = context.measureText(ann.text).width;
                context.fillStyle = colors.statsBg || 'rgba(0,0,0,0.6)';
                context.fillRect(pos.x, pos.y - 18, textWidth + 10, 22);
                if (isSelected && context === ctx) {
                    context.strokeStyle = colors.selection;
                    context.lineWidth = 2;
                    context.strokeRect(pos.x, pos.y - 18, textWidth + 10, 22);
                }
                context.fillStyle = traceColor;
                context.textAlign = 'left';
                context.textBaseline = 'middle';
                context.fillText(ann.text, pos.x + 5, pos.y - 7);
            });
        }
        function drawPointAnnotations(context, targetView, plotArea, state, colors) {
             if (!state.annotationsVisible || !state.pointAnnotations) return;
             state.pointAnnotations.forEach((ann, index) => {
                 const chInfo = state.channelInfo[ann.channel];
                 if (!chInfo) return;

                 let traceColor = chInfo.color;
                 if(colors.bwTraces) {
                    const visibleChannels = getVisibleChannels(state);
                    const colorIndex = visibleChannels.indexOf(ann.channel);
                    traceColor = colorIndex > -1 ? colors.bwTraces[colorIndex % colors.bwTraces.length] : colors.text;
                 }
                 const isSelected = activeInteraction.type === 'pointAnnotation' && activeInteraction.index === index;

                 const pos = dataToScreen({ time: ann.time, voltage: ann.voltage }, targetView, state, ann.channel, plotArea);
                 
                 context.fillStyle = traceColor;
                 context.beginPath();
                 context.arc(pos.x, pos.y, isSelected ? 6 : 5, 0, 2 * Math.PI);
                 context.fill();
                 if (isSelected) {
                    context.strokeStyle = colors.selection;
                    context.lineWidth = 2;
                    context.stroke();
                 }

                 const textX = pos.x + ann.textPos.dx;
                 const textY = pos.y + ann.textPos.dy;
                 context.font = '14px Segoe UI';
                 const textWidth = context.measureText(ann.text).width;
                 
                 context.beginPath();
                 context.moveTo(pos.x, pos.y);
                 context.lineTo(textX, textY);
                 context.strokeStyle = traceColor;
                 context.lineWidth = 1;
                 context.stroke();

                 context.fillStyle = colors.statsBg || 'rgba(0,0,0,0.6)';
                 context.fillRect(textX, textY - 11, textWidth + 10, 22);
                 context.fillStyle = traceColor;
                 context.textAlign = 'left';
                 context.textBaseline = 'middle';
                 context.fillText(ann.text, textX + 5, textY);
             });
        }
        function snapToCommonScale(value) {
            if (value <= 0) return value;
            const power = Math.pow(10, Math.floor(Math.log10(value)));
            const normalized = value / power; // Value will be between 1.0 and 9.99...
            if (normalized < 1.5) return 1 * power;
            if (normalized < 3.5) return 2 * power;
            if (normalized < 7.5) return 5 * power;
            return 10 * power;
        }

        const commonScaleSteps = [1, 2, 5];
        function getNextSnapScale(value, direction) {
            if (value <= 0) return value;
            const power = Math.pow(10, Math.floor(Math.log10(value)));
            let mantissa = value / power;

            let currentIndex = -1;
            let minDiff = Infinity;
            commonScaleSteps.forEach((step, i) => {
                const diff = Math.abs(mantissa - step);
                if (diff < minDiff) {
                    minDiff = diff;
                    currentIndex = i;
                }
            });

            if (direction < 0) { // Zoom in (mouse wheel scrolls up, deltaY is negative)
                if (mantissa < commonScaleSteps[currentIndex] + 1e-9) { // If we are at a step, go to the next smaller one
                    currentIndex--;
                }
                if (currentIndex < 0) {
                    return 5 * (power / 10);
                }
                return commonScaleSteps[currentIndex] * power;
            } else { // Zoom out
                if (mantissa > commonScaleSteps[currentIndex] - 1e-9) { // If we are at a step, go to the next bigger one
                    currentIndex++;
                }
                if (currentIndex >= commonScaleSteps.length) {
                    return 1 * (power * 10);
                }
                return commonScaleSteps[currentIndex] * power;
            }
        }

        function fullResetView(){
            const s = getActiveState(); if (!s) return;
            let min = Infinity, max = -Infinity;
            const visibleChannels = getVisibleChannels(s);
            const channelsToScan = visibleChannels.length > 0 ? visibleChannels : Object.keys(s.waveforms);

            channelsToScan.forEach(chKey => {
                const data = s.waveforms[chKey];
                for (let v of data) {
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
            });
            
            if (min === Infinity) { min = -1; max = 1;}
            const margin = (max - min) * 0.1 || 1;
            
            s.view = { startIndex: 0, endIndex: s.metadata.numPoints };
            Object.values(s.channelInfo).forEach(chInfo => {
                chInfo.vMin = min - margin;
                chInfo.vMax = max + margin;
            });
            updateControlsFromView(s);
            draw();
        }
        function fitYToAllVisible() {
            const s=getActiveState(); if (!s) return;
            let min = Infinity, max = -Infinity;
            const start = Math.floor(s.view.startIndex), end = Math.ceil(s.view.endIndex);
            
            const visibleChannels = getVisibleChannels(s);
            if(visibleChannels.length === 0) return;

            visibleChannels.forEach(c => {
                const data = s.waveforms[c];
                for (let i = start; i < end; i++) {
                    const v = data[i];
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
            });
            if (min === Infinity) return;
            const margin = (max - min) * 0.1 || 1;
            
            visibleChannels.forEach(c => {
                s.channelInfo[c].vMin = min - margin;
                s.channelInfo[c].vMax = max + margin;
            });
            updateControlsFromView(s);
            draw();
        }
        function fitYToChannel(channelId) {
            const s = getActiveState(); if (!s || !s.waveforms[channelId]) return;
            let min = Infinity, max = -Infinity;
            const start = Math.max(0, Math.floor(s.view.startIndex)), end = Math.min(s.metadata.numPoints, Math.ceil(s.view.endIndex));
            const data = s.waveforms[channelId];

            for (let i = start; i < end; i++) {
                const v = data[i];
                if (v < min) min = v;
                if (v > max) max = v;
            }
            if (min === Infinity) return;
            const margin = (max - min) * 0.1 || 0.1;
            const chInfo = s.channelInfo[channelId];
            chInfo.vMin = min - margin;
            chInfo.vMax = max + margin;
            updateControlsFromView(s);
            draw();
        }
        function updateControlsFromView(state){
            if (!state) return;
            const timeRange = (state.view.endIndex - state.view.startIndex) * state.metadata.timePerPoint;
            if (timeRange > 0) {
                 document.getElementById('timeScale').value = formatEng(timeRange / X_DIVS, 's');
            }
            
            Object.keys(state.channelInfo).forEach(chId => {
                const sanitizedChId = chId.replace(/[^a-zA-Z0-9]/g, '_');
                const input = document.getElementById(`${sanitizedChId}_vscale`);
                if (input) {
                    const chInfo = state.channelInfo[chId];
                    const vRange = chInfo.vMax - chInfo.vMin;
                    input.value = formatEng(vRange / Y_DIVS, chInfo.units);
                }
            });
        }
        function updateChannelScaleControls(state) {
            const container = document.getElementById('voltageScaleContainer');
            container.innerHTML = '';
            if (!state) return;

            Object.keys(state.channelInfo).forEach(chId => {
                const chInfo = state.channelInfo[chId];
                const item = document.createElement('div');
                item.className = 'control-item';
                const sanitizedChId = chId.replace(/[^a-zA-Z0-9]/g, '_');
                item.innerHTML = `<span class="control-label" title="${chInfo.name}">${chInfo.name.substring(0,10)} (${chInfo.units}/div)</span><input type="text" class="control-input" id="${sanitizedChId}_vscale" data-channel-id="${chId}">`;
                container.appendChild(item);

                const input = item.querySelector('input');
                input.addEventListener('change', (e) => {
                    const s = getActiveState();
                    if (!s) return;
                    
                    let newVScale = parseEng(e.target.value);
                    if (displayOptions.discreteZoom) {
                        newVScale = snapToCommonScale(newVScale);
                    }

                    const targetChId = e.target.dataset.channelId;
                    const chInfo = s.channelInfo[targetChId];

                    if (!isNaN(newVScale) && newVScale > 0 && chInfo) {
                        const newVSpan = newVScale * Y_DIVS;
                        const vCenter = chInfo.vMin + (chInfo.vMax - chInfo.vMin) / 2;
                        chInfo.vMin = vCenter - newVSpan / 2;
                        chInfo.vMax = vCenter + newVSpan / 2;
                        draw();
                    }
                    updateControlsFromView(s);
                });
            });
            updateControlsFromView(state);
        }
        function updateCursorReadouts(state) { 
            const { cursors } = state;
            const { x1, x2, y1, y2 } = cursors;
            const dt = Math.abs(x2 - x1), dv = Math.abs(y2 - y1);
            const freq = dt > 0 ? 1 / dt : 0;
            const firstChannel = getVisibleChannels(state)[0];
            const unit = firstChannel ? state.channelInfo[firstChannel].units : 'V';
            document.getElementById('cursorYUnit').textContent = unit;
            document.getElementById('deltaX').value = formatEng(dt, 's'); 
            document.getElementById('deltaFreq').value = formatEng(freq, 'Hz'); 
            document.getElementById('deltaY').value = formatEng(dv, unit); 
            document.getElementById('t1').value = formatEng(x1, 's'); 
            document.getElementById('t2').value = formatEng(x2, 's'); 
            document.getElementById('v1').value = formatEng(y1, unit); 
            document.getElementById('v2').value = formatEng(y2, unit); 
        }
        function calculateStats(state, ch) {
            const { view, waveforms } = state;
            const data = waveforms[ch];
            let min = Infinity, max = -Infinity, sum = 0, sumSq = 0;
            const s = Math.floor(view.startIndex), e = Math.ceil(view.endIndex);
            const count = e - s;
            if (count <= 0) return { min: NaN, max: NaN, avg: NaN, rms: NaN };

            for (let i = s; i < e; i++) {
                const voltVal = data[i];
                if (voltVal !== undefined && !isNaN(voltVal)) {
                    if (voltVal < min) min = voltVal;
                    if (voltVal > max) max = voltVal;
                    sum += voltVal;
                    sumSq += voltVal * voltVal;
                }
            }
            return { min, max, avg: sum / count, rms: Math.sqrt(sumSq / count) };
        }

        function handleFileSelect(e) { 
             for (const file of e.target.files) {
                 loadFile(file); 
             }
             e.target.value = ''; 
        }
        
        function loadFile(file) {
            statusText.textContent = `Loading ${file.name}...`;
            const reader = new FileReader();
            const fileNameLower = file.name.toLowerCase();

            if (fileNameLower.endsWith('.wfm')) {
                reader.onload = (e) => handleWfmLoad(e.target.result, file.name);
                reader.readAsArrayBuffer(file);
            } else if (fileNameLower.endsWith('.csv')) {
                reader.onload = (e) => handleCsvLoad(e.target.result, file.name);
                reader.readAsText(file);
            } else if (fileNameLower.endsWith('.graphx')) {
                reader.onload = (e) => loadSession(e.target.result);
                reader.readAsText(file);
            } else {
                 statusText.textContent = `Unsupported file type: ${file.name}`;
            }
        }
        
        function handleCsvLoad(csvText, fileName) {
            showCsvOptionsModal(csvText, fileName);
        }

        function handleWfmLoad(arrayBuffer, fileName) {
             try {
                 let parser = null;
                 const view = new DataView(arrayBuffer);
                 let versionString = '';
                 if (arrayBuffer.byteLength > 10) {
                     for (let i = 0; i < 8; i++) {
                         const charCode = view.getUint8(2 + i);
                         if (charCode === 0) break;
                         versionString += String.fromCharCode(charCode);
                     }
                 }
                 
                 if (versionString.startsWith(':WFM#00')) {
                     parser = new TekWfmParser(arrayBuffer);
                 } else if (arrayBuffer.byteLength > 2 && view.getUint16(0, true) === 0xA5A5) {
                     parser = new RigolWfmParser(arrayBuffer);
                 } else {
                     throw new Error("Invalid or unsupported WFM file format.");
                 }

                 if (!parser.isValid()) {
                     throw new Error("Invalid or unsupported WFM file format (parser validation failed).");
                 }
                 
                 const loadOptions = { timeMultiplier: 1, overrides: {} };
                 if (parser instanceof RigolWfmParser) {
                     for (let i = 1; i <= 4; i++) {
                         if (parser.isChannelWritten(i)) {
                             const chKey = `channel${i}`;
                             loadOptions.overrides[chKey] = { multiplier: 1 };
                         }
                     }
                 }
                 
                 const newState = createDefaultTabState(fileName, parser, loadOptions.overrides);
                 const newIndex = tabStates.length;
                 tabStates.push(newState);
                 addTabToUI(fileName, newIndex);
                 switchToTab(newIndex);
                 fitYToAllVisible();
                 statusText.textContent = `Loaded: ${fileName}`;
             } catch(err) {
                 statusText.textContent = `Error processing ${fileName}: ${err.message}`;
                 console.error(err);
             }
        }
        
        function addTabToUI(fileName, index) {
            const tab = document.createElement('div');
            tab.className = 'tab-item';
            tab.dataset.index = index;
            tab.innerHTML = `<span class="tab-name" title="${fileName}">${fileName}</span><span class="tab-close">&times;</span>`;
            
            tab.addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-close')) { 
                    e.stopPropagation(); 
                    if (tabStates[index] && tabStates[index].isOverlap) {
                       // The create button is not a checkbox anymore, so no need to sync
                    }
                    closeTab(index); 
                } else { 
                    switchToTab(index); 
                }
            });

            // Insert before the overlap button
            const overlapBtn = document.getElementById('createOverlapBtn');
            tabContainer.insertBefore(tab, overlapBtn);
        }

        function switchToTab(index) {
            if (index < 0 || index >= tabStates.length) {
                activeTabIndex = -1;
                updateUIFromState();
                draw();
                return;
            }
            activeTabIndex = index;
            document.querySelectorAll('.tab-item').forEach(tab => {
                tab.classList.toggle('active', parseInt(tab.dataset.index) === index);
            });
            updateUIFromState();
            draw();
        }

        function closeTab(index) {
            if (index < 0 || index >= tabStates.length) return;
            tabStates.splice(index, 1);
            
            // Rebuild UI for tabs
            const overlapBtn = document.getElementById('createOverlapBtn');
            tabContainer.innerHTML = '';
            tabContainer.appendChild(overlapBtn);
            tabStates.forEach((state, i) => addTabToUI(state.fileName, i));
            
            let newActiveIndex = activeTabIndex;
            if (activeTabIndex === index) {
                newActiveIndex = Math.min(index, tabStates.length - 1);
            } else if (activeTabIndex > index) {
                newActiveIndex--;
            }
            switchToTab(newActiveIndex);
        }
        
        function updateUIFromState() {
            const state = getActiveState();
            const fileDetailsPanel = document.getElementById('fileDetailsPanel');
            const annotationSelector = document.getElementById('annotationChannelSelector');

            if (!state) {
                document.getElementById('fileInfo').innerHTML = `<div>Drop a file or click Load</div><div>Points: -</div>`;
                ['timeScale', 'deltaX', 'deltaFreq', 'deltaY', 't1', 't2', 'v1', 'v2'].forEach(id => document.getElementById(id).value = '-');
                document.getElementById('cursorPanel').style.display = 'none';
                document.getElementById('cursorBtn').classList.remove('active');
                document.getElementById('annotateBtn').classList.remove('active');
                document.getElementById('clearAnnotationsBtn').style.display = 'none';
                fileDetailsPanel.style.display = 'none';
                annotationSelector.style.display = 'none';
                setupChannelUI(null);
                updateChannelScaleControls(null);
                return;
            }
            
            annotationSelector.style.display = (state.drawOrder.length > 0) ? 'flex' : 'none';
            document.getElementById('fileInfo').innerHTML = `<div>${state.fileName}</div><div>Points: ${state.metadata.numPoints}</div>`;
            setupChannelUI(state);
            updateChannelScaleControls(state);
            document.getElementById('cursorBtn').classList.toggle('active', state.cursors.enabled);
            document.getElementById('cursorPanel').style.display = state.cursors.enabled ? 'block' : 'none';
            if(state.cursors.enabled) updateCursorReadouts(state);
            updateAnnotationButtonState();
            document.getElementById('measurement-controls').style.display = document.getElementById('showStatsCheckbox').checked && !state.isOverlap ? 'block' : 'none';
            updateControlsFromView(state);

            if (state.parser && !(state.parser instanceof CsvParser) && !(state.parser instanceof PastedDataParser)) {
                updateFileDetailsPanel(state.parser);
                fileDetailsPanel.style.display = 'block';
            } else {
                fileDetailsPanel.style.display = 'none';
            }
        }

        function updateFileDetailsPanel(parser) {
            const contentDiv = document.getElementById('fileDetailsContent');
            contentDiv.innerHTML = '';
            let details = '';

            if (parser instanceof TekWfmParser) {
                details += `<div><span>Format:</span> <span>Tektronix</span></div>`;
                details += `<div><span>Version:</span> <span>${parser.getString(2, 8).trim()}</span></div>`;
                details += `<div><span>Endian:</span> <span>${parser.littleEndian ? 'Little' : 'Big'}</span></div>`;
                details += `<div><span>Time/Point:</span> <span>${formatEng(parser.getTimeScale(), 's')}</span></div>`;
                details += `<div><span>V Units:</span> <span>${parser.getVoltageUnits()}</span></div>`;
                details += `<div><span>V Scale:</span> <span>${parser.getFloat64(166).toExponential(4)}</span></div>`;
                details += `<div><span>V Offset:</span> <span>${formatEng(parser.getFloat64(174), 'V')}</span></div>`;
                details += `<hr>`;
                details += `<div><span>User V/div:</span> <span>${formatEng(parser.getUserVoltsPerDiv(), 'V')}</span></div>`;
                details += `<div><span>User V Offset:</span> <span>${parser.getUserVerticalOffset().toFixed(3)} div</span></div>`;
            } else if (parser instanceof RigolWfmParser) {
                details += `<div><span>Format:</span> <span>Rigol</span></div>`;
                details += `<div><span>Sample Freq:</span> <span>${formatEng(parser.getSamplingFrequency(), 'Hz')}</span></div>`;
                for (let i = 1; i <= 4; i++) {
                    if (parser.isChannelWritten(i)) {
                        details += `<hr>`;
                        details += `<div><span>Channel ${i} (Header):</span> <span></span></div>`;
                        details += `<div><span>&nbsp;&nbsp;V/div:</span> <span>${formatEng(parser.getVoltageScale(i), 'V')}</span></div>`;
                        details += `<div><span>&nbsp;&nbsp;V Offset:</span> <span>${formatEng(parser.getVoltageOffset(i), 'V')}</span></div>`;
                    }
                }
            }
            contentDiv.innerHTML = details;
        }

        function setupChannelUI(state) {
            const btnContainer = document.getElementById('channelButtonContainer');
            const cursorContainer = document.getElementById('cursorTrackContainer');
            const annotationSelector = document.getElementById('annotationChannelSelector');

            btnContainer.innerHTML = '';
            cursorContainer.innerHTML = '<label><input type="radio" name="cursorTrack" value="null" checked> None</label>';
            annotationSelector.innerHTML = '';

            if (!state || state.drawOrder.length === 0) {
                document.getElementById('swapOrderBtn').style.display = 'none';
                return;
            };

            document.getElementById('swapOrderBtn').style.display = state.isOverlap ? 'none' : 'block';
            
            annotationSelector.innerHTML = '<span style="font-size: 13px; color: #ccc;">Annotate:</span>';

            for (const chId of state.drawOrder) {
                const info = state.channelInfo[chId];
                if (!info) continue;
                
                const btn = document.createElement('button');
                btn.className = `channel-button`;
                btn.classList.toggle('active', info.visible);
                if(btn.classList.contains('active')) btn.style.background = info.color;
                btn.dataset.channel = chId;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'ch-name';
                nameSpan.title = info.name;
                nameSpan.innerHTML = `<i class="fas fa-wave-square" style="color: ${info.color}"></i> ${info.name}`;
                btn.appendChild(nameSpan);

                const orderSpan = document.createElement('span');
                orderSpan.className = 'ch-order';
                btn.appendChild(orderSpan);

                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.className = 'ch-color-picker';
                colorPicker.value = info.color;
                btn.appendChild(colorPicker);

                colorPicker.addEventListener('input', (e) => {
                    const s = getActiveState(); if (!s) return;
                    s.channelInfo[chId].color = e.target.value;
                    btn.style.background = s.channelInfo[chId].visible ? e.target.value : '#454545';
                    nameSpan.querySelector('i').style.color = e.target.value;
                    draw();
                });
                
                btn.addEventListener('click', e => {
                    if (e.target.type === 'color') return; // Prevent toggle when clicking color picker
                    const s = getActiveState(); if (!s) return;
                    const chInfo = s.channelInfo[chId];
                    chInfo.visible = !chInfo.visible;
                    btn.classList.toggle('active', chInfo.visible);
                    btn.style.background = chInfo.visible ? chInfo.color : '#454545';
                    draw();
                });
                colorPicker.addEventListener('click', (e) => e.stopPropagation());

                btnContainer.appendChild(btn);
                
                const radioLabel = document.createElement('label');
                radioLabel.innerHTML = `<input type="radio" name="cursorTrack" value="${chId}"> <span title="${info.name}">${info.name.substring(0, 10)}</span>`;
                radioLabel.querySelector('input').addEventListener('change', e => {
                    const s = getActiveState(); if (s) { s.cursors.trackingChannel = e.target.value; trackCursors(); draw(); }
                });
                cursorContainer.appendChild(radioLabel);

                const selBtn = document.createElement('button');
                selBtn.className = 'tool-button';
                selBtn.textContent = info.name.substring(0, 12);
                selBtn.title = info.name;
                selBtn.dataset.channel = chId;
                selBtn.style.padding = '4px 8px';
                selBtn.style.fontSize = '12px';
                selBtn.style.minWidth = '50px';
                selBtn.addEventListener('click', () => setAnnotationChannel(chId));
                annotationSelector.appendChild(selBtn);
            }
            
            if (state.drawOrder.length > 0 && !state.isOverlap) {
                 const firstBtn = document.querySelector(`.channel-button[data-channel="${state.drawOrder[0]}"] .ch-order`);
                 if(firstBtn) firstBtn.textContent='(Back)';
                 if (state.drawOrder.length > 1) {
                      const lastBtn = document.querySelector(`.channel-button[data-channel="${state.drawOrder[state.drawOrder.length-1]}"] .ch-order`);
                      if(lastBtn) lastBtn.textContent='(Front)';
                 }
            }
            const radioToCheck = cursorContainer.querySelector(`input[name="cursorTrack"][value="${state.cursors.trackingChannel || 'null'}"]`);
            if (radioToCheck) radioToCheck.checked = true;

            updateAnnotationChannelUI(state);
        }

        function hitTestWaveform(mousePos, state) {
            if (!state) return null;
            const {x: mouseX, y: mouseY} = mousePos;
            
            for (const ch of [...state.drawOrder].reverse()) {
                const chInfo = state.channelInfo[ch];
                if (!chInfo.visible || !state.waveforms[ch]) continue;

                const dataTimePerPoint = chInfo.originalMetadata ? chInfo.originalMetadata.timePerPoint : state.metadata.timePerPoint;
                const timeOffset = state.metadata.timeStart || 0;
                const viewStartTime = (state.view.startIndex * state.metadata.timePerPoint);
                const viewTimeSpan = (state.view.endIndex - state.view.startIndex) * state.metadata.timePerPoint;
                
                const plotArea = getPlotArea(canvas.clientWidth, canvas.clientHeight, state);
                const timeAtMouse = viewStartTime + ((mouseX - plotArea.x) / plotArea.width) * viewTimeSpan + timeOffset;
                const dataIndex = Math.round((timeAtMouse - timeOffset) / dataTimePerPoint);

                if (dataIndex >= 0 && dataIndex < state.waveforms[ch].length) {
                    const waveformVoltage = state.waveforms[ch][dataIndex];
                    const vRange = chInfo.vMax - chInfo.vMin;
                    const screenY = plotArea.y + ((chInfo.vMax - waveformVoltage) / vRange) * plotArea.height;

                    if (Math.abs(mouseY - screenY) < 8) {
                        return ch;
                    }
                }
            }
            return null;
        }

        function getInteractionAtPos(pos, state) {
            const handleSize = 8, tol = handleSize / 2 + 2;
            const refCh = getVisibleChannels(state)[0];

            for (let i = state.pointAnnotations.length - 1; i >= 0; i--) {
                const ann = state.pointAnnotations[i];
                const screenPos = dataToScreen({time: ann.time, voltage: ann.voltage}, state.view, state, ann.channel);
                ctx.font = '14px Segoe UI';
                const textWidth = ctx.measureText(ann.text).width;
                const textX = screenPos.x + ann.textPos.dx, textY = screenPos.y + ann.textPos.dy;
                if (pos.x >= textX && pos.x <= textX + textWidth + 10 && pos.y >= textY - 11 && pos.y <= textY + 11) { return { type: 'pointAnnotation', index: i, handle: 'text' }; }
                if (Math.hypot(pos.x - screenPos.x, pos.y - screenPos.y) < tol + 3) return { type: 'pointAnnotation', index: i, handle: 'body' };
            }
            for (let i = state.textAnnotations.length - 1; i >= 0; i--) {
                const ann = state.textAnnotations[i];
                const annChannel = ann.channel || refCh;
                if(!annChannel) continue;
                const screenPos = dataToScreen({time: ann.time, voltage: ann.voltage}, state.view, state, annChannel);
                ctx.font = '14px Segoe UI';
                const textWidth = ctx.measureText(ann.text).width;
                if (pos.x >= screenPos.x && pos.x <= screenPos.x + textWidth + 10 && pos.y >= screenPos.y - 18 && pos.y <= screenPos.y + 4) { return { type: 'textAnnotation', index: i, handle: 'body' }; }
            }
            for (let i = state.annotations.length - 1; i >= 0; i--) {
                const box = state.annotations[i];
                const boxCh = box.channel || refCh;
                if(!boxCh) continue;
                const p1 = dataToScreen({time: box.t1, voltage: box.v1}, state.view, state, boxCh);
                const p2 = dataToScreen({time: box.t2, voltage: box.v2}, state.view, state, boxCh);
                const x = Math.min(p1.x, p2.x), y = Math.min(p1.y, p2.y), w = Math.abs(p1.x - p2.x), h = Math.abs(p1.y - p2.y);
                const isSelected = activeInteraction.type === 'annotation' && activeInteraction.index === i;
                if (isSelected) {
                    if (Math.abs(pos.x - x) < tol && Math.abs(pos.y - y) < tol) return { type: 'annotation', index: i, handle: 'tl' };
                    if (Math.abs(pos.x - (x + w)) < tol && Math.abs(pos.y - y) < tol) return { type: 'annotation', index: i, handle: 'tr' };
                    if (Math.abs(pos.x - x) < tol && Math.abs(pos.y - (y + h)) < tol) return { type: 'annotation', index: i, handle: 'bl' };
                    if (Math.abs(pos.x - (x + w)) < tol && Math.abs(pos.y - (y + h)) < tol) return { type: 'annotation', index: i, handle: 'br' };
                }
                if (pos.x > x && pos.x < x + w && pos.y > y && pos.y < y + h) return { type: 'annotation', index: i, handle: 'body' };
            }
            if (state.cursors.enabled) {
                if (!refCh) return { type: null };
                const x1_s = dataToScreen({time: state.cursors.x1, voltage: 0}, state.view, state, refCh).x;
                const x2_s = dataToScreen({time: state.cursors.x2, voltage: 0}, state.view, state, refCh).x;
                const y1_s = dataToScreen({time: 0, voltage: state.cursors.y1}, state.view, state, refCh).y;
                const y2_s = dataToScreen({time: 0, voltage: state.cursors.y2}, state.view, state, refCh).y;
                if (Math.abs(pos.x - x1_s) < tol) return { type: 'cursor', handle: 'x1' };
                if (Math.abs(pos.x - x2_s) < tol) return { type: 'cursor', handle: 'x2' };
                if (Math.abs(pos.y - y1_s) < tol) return { type: 'cursor', handle: 'y1' };
                if (Math.abs(pos.y - y2_s) < tol) return { type: 'cursor', handle: 'y2' };
            }
            const hitChannel = hitTestWaveform(pos, state);
            if (hitChannel) { return { type: 'channel-drag', channel: hitChannel }; }
            return { type: null };
        }
        
        canvas.addEventListener('mousedown', e => {
            const state = getActiveState(); if (!state) return;
            if (textAnnotationMode) { createTextAnnotationInput(e); return; }
            if (pointAnnotationMode) { createPointAnnotation(e); return; }
            
            if (e.shiftKey) {
                activeInteraction = { type: 'measure-drag' };
                dragStart = { x: e.offsetX, y: e.offsetY }; dragEnd = { ...dragStart };
                return;
            }

            const interaction = getInteractionAtPos({ x: e.offsetX, y: e.offsetY }, state);
            activeInteraction = { ...interaction, startX: e.offsetX, startY: e.offsetY };
            
            if (interaction.type === 'channel-drag') {
                const chInfo = state.channelInfo[interaction.channel];
                activeInteraction.startVMin = chInfo.vMin;
                activeInteraction.startVMax = chInfo.vMax;
                isPanning = false;
            } else if (interaction.type === 'pointAnnotation' && interaction.handle === 'text') {
                const ann = state.pointAnnotations[interaction.index];
                activeInteraction.startTextPos = {...ann.textPos};
                isPanning = false;
            } else if (interaction.type) {
                isPanning = false;
                draw();
            } else {
                if (zoomModeEnabled) {
                    activeInteraction.type = 'zoom-drag';
                    dragStart = { x: e.offsetX, y: e.offsetY }; dragEnd = { ...dragStart };
                } else {
                    isPanning = true;
                    const vRanges = {};
                    getVisibleChannels(state).forEach(ch => {
                        vRanges[ch] = { vMin: state.channelInfo[ch].vMin, vMax: state.channelInfo[ch].vMax };
                    });
                    const panningChannel = getChannelFromMousePosition({x: e.offsetX, y: e.offsetY}, state);
                    panStart = { x: e.offsetX, y: e.offsetY, viewStart: state.view.startIndex, viewEnd: state.view.endIndex, vRanges: vRanges, panningChannel: panningChannel };
                    canvas.style.cursor = 'grabbing';
                }
            }
        });
        
        canvas.addEventListener('mousemove', e => {
            const state = getActiveState(); if (!state) return;
            lastMousePos = {x: e.offsetX, y: e.offsetY};
            const { type, channel, handle, index, startVMin, startVMax, startY, startX, startTextPos } = activeInteraction;

            if (type === 'channel-drag') {
                const plotArea = getPlotArea(canvas.clientWidth, canvas.clientHeight, state);
                const dy = e.offsetY - startY;
                const vRange = startVMax - startVMin;
                const vPerPixel = vRange / plotArea.height;
                const vDelta = dy * vPerPixel;
                
                const chInfo = state.channelInfo[channel];
                chInfo.vMin = startVMin + vDelta;
                chInfo.vMax = startVMax + vDelta;
                draw();
                return;
            } else if (type === 'cursor') {
                const { time, voltage } = screenToData({ x: e.offsetX, y: e.offsetY }, state.view, state);
                if (handle.startsWith('x')) { state.cursors[handle] = time; trackCursors(); } else { state.cursors[handle] = voltage; }
                draw();
                return;
            } else if (type === 'textAnnotation' || (type === 'annotation' && handle === 'body')) {
                 const { time, voltage } = screenToData({ x: e.offsetX, y: e.offsetY }, state.view, state);
                 state.textAnnotations[index].time = time; state.textAnnotations[index].voltage = voltage;
                 draw();
                 return;
            } else if (type === 'pointAnnotation' && handle === 'text') {
                 const dx = e.offsetX - startX;
                 const dy = e.offsetY - startY;
                 const ann = state.pointAnnotations[index];
                 ann.textPos.dx = startTextPos.dx + dx;
                 ann.textPos.dy = startTextPos.dy + dy;
                 draw();
                 return;
            } else if (type === 'zoom-drag' || type === 'measure-drag') {
                dragEnd = { x: e.offsetX, y: e.offsetY };
                draw();
            } else if (isPanning) {
                const plotArea = getPlotArea(canvas.clientWidth, canvas.clientHeight, state);
                const dx = e.offsetX - panStart.x;
                const dy = e.offsetY - panStart.y;
                
                const indexPerPixel = (panStart.viewEnd - panStart.viewStart) / plotArea.width;
                const indexShift = dx * indexPerPixel;
                let newStart = panStart.viewStart - indexShift, newEnd = panStart.viewEnd - indexShift;
                if (newStart < 0) { newEnd -= newStart; newStart = 0; }
                if (newEnd > state.metadata.numPoints) { newStart -= (newEnd - state.metadata.numPoints); newEnd = state.metadata.numPoints; }
                if (newStart < 0) newStart = 0;
                state.view.startIndex = newStart; state.view.endIndex = newEnd;
                
                if (displayOptions.separateView && !state.isOverlap && panStart.panningChannel) {
                    const ch = panStart.panningChannel;
                    if (panStart.vRanges[ch]) {
                        const chInfo = state.channelInfo[ch];
                        const vRange = panStart.vRanges[ch].vMax - panStart.vRanges[ch].vMin;
                        const PADDING = getDynamicPadding(state);
                        const totalPlotHeight = canvas.clientHeight - PADDING.top - PADDING.bottom;
                        const visCh = getVisibleChannels(state);
                        const totalGapHeight = (visCh.length > 1) ? (visCh.length - 1) * SEPARATE_VIEW_GAP : 0;
                        const individualPlotHeight = (totalPlotHeight - totalGapHeight) / visCh.length;
                        if (individualPlotHeight > 0) {
                            const vPerPixel = vRange / individualPlotHeight;
                            const vDelta = dy * vPerPixel;
                            chInfo.vMin = panStart.vRanges[ch].vMin + vDelta;
                            chInfo.vMax = panStart.vRanges[ch].vMax + vDelta;
                        }
                    }
                } else if (!displayOptions.separateView || state.isOverlap) {
                    getVisibleChannels(state).forEach((ch) => {
                        if (panStart.vRanges[ch]) {
                            const chInfo = state.channelInfo[ch];
                            const vRange = panStart.vRanges[ch].vMax - panStart.vRanges[ch].vMin;
                            const vPerPixel = vRange / plotArea.height;
                            const vDelta = dy * vPerPixel;
                            chInfo.vMin = panStart.vRanges[ch].vMin + vDelta;
                            chInfo.vMax = panStart.vRanges[ch].vMax + vDelta;
                        }
                    });
                }

                updateControlsFromView(state); draw();
            } else {
                const hitChannelId = hitTestWaveform({ x: e.offsetX, y: e.offsetY }, state);
                hoveredChannelInfo = hitChannelId ? { name: state.channelInfo[hitChannelId].name, color: state.channelInfo[hitChannelId].color, x: e.offsetX, y: e.offsetY } : null;
                if (hitChannelId !== lastHoveredChannelId) {
                    draw();
                }
                lastHoveredChannelId = hitChannelId;
                const interaction = getInteractionAtPos({ x: e.offsetX, y: e.offsetY }, state);
                if (zoomModeEnabled) canvas.style.cursor = 'zoom-in';
                else if (textAnnotationMode) canvas.style.cursor = 'text';
                else if (pointAnnotationMode) canvas.style.cursor = 'crosshair';
                else if (interaction.type === 'channel-drag') canvas.style.cursor = 'ns-resize';
                else if (interaction.type === 'annotation' || interaction.type === 'textAnnotation' || interaction.type === 'pointAnnotation') canvas.style.cursor = interaction.handle === 'body' || interaction.handle === 'text' ? 'move' : 'pointer';
                else if (interaction.type === 'cursor') canvas.style.cursor = interaction.handle.startsWith('x') ? 'ew-resize' : 'ns-resize';
                else canvas.style.cursor = 'grab';
            }
        });
        
        canvas.addEventListener('mouseup', e => {
            const state = getActiveState(); if (!state) return;

            const { type } = activeInteraction;
            if (type === 'zoom-drag') {
                if (Math.abs(dragEnd.x - dragStart.x) >= 10 && Math.abs(dragEnd.y - dragStart.y) >= 10) {
                    const { time: t1 } = screenToData({x: Math.min(dragStart.x, dragEnd.x), y: 0}, state.view, state);
                    const { time: t2 } = screenToData({x: Math.max(dragStart.x, dragEnd.x), y: 0}, state.view, state);
                    const newStartIndex = Math.max(0, (t1 - (state.metadata.timeStart || 0)) / state.metadata.timePerPoint);
                    const newEndIndex = Math.min(state.metadata.numPoints, (t2 - (state.metadata.timeStart || 0)) / state.metadata.timePerPoint);
                    
                    if (newEndIndex - newStartIndex >= 10) {
                        state.view.startIndex = newStartIndex;
                        state.view.endIndex = newEndIndex;
                        getVisibleChannels(state).forEach(ch => {
                           const { voltage: v2 } = screenToData({x:0, y: Math.min(dragStart.y, dragEnd.y)}, state.view, state, ch);
                           const { voltage: v1 } = screenToData({x:0, y: Math.max(dragStart.y, dragEnd.y)}, state.view, state, ch);
                           state.channelInfo[ch].vMin = v1;
                           state.channelInfo[ch].vMax = v2;
                        });
                        updateControlsFromView(state);
                    }
                }
                zoomModeEnabled = false;
                statusText.textContent = `Loaded: ${state.fileName}`;
            } else if (type === 'measure-drag') {
                if (state.annotationMode && Math.abs(dragEnd.x - dragStart.x) > 5) {
                    const annotationCh = state.annotationChannel || getVisibleChannels(state)[0];
                    if (annotationCh) {
                        let plotArea = null;
                        const { width, height } = canvas.getBoundingClientRect();
                        const visibleChannels = getVisibleChannels(state);

                        if (displayOptions.separateView && visibleChannels.length > 0 && !state.isOverlap) {
                            const PADDING = getDynamicPadding(state);
                            const totalPlotHeight = height - PADDING.top - PADDING.bottom;
                            const totalGapHeight = (visibleChannels.length > 1) ? (visibleChannels.length - 1) * SEPARATE_VIEW_GAP : 0;
                            const individualPlotHeight = (totalPlotHeight - totalGapHeight) / visibleChannels.length;
                            if (individualPlotHeight > 0) {
                                const blockHeight = individualPlotHeight + SEPARATE_VIEW_GAP;
                                const relativeY = dragStart.y - PADDING.top;
                                const blockIndex = Math.max(0, Math.floor(relativeY / blockHeight));
                                
                                if (blockIndex < visibleChannels.length) {
                                    plotArea = {
                                        x: PADDING.left,
                                        y: PADDING.top + blockIndex * blockHeight,
                                        width: width - PADDING.left - PADDING.right,
                                        height: individualPlotHeight
                                    };
                                }
                            }
                        } else {
                            plotArea = getPlotArea(width, height, state);
                        }

                        if (plotArea) {
                            const { time: t_start, voltage: v_start } = screenToData({ x: dragStart.x, y: dragStart.y }, state.view, state, annotationCh, plotArea);
                            const { time: t_end, voltage: v_end } = screenToData({ x: dragEnd.x, y: dragEnd.y }, state.view, state, annotationCh, plotArea);
                            state.annotations.push({ t1: t_start, v1: v_start, t2: t_end, v2: v_end, channel: annotationCh, text: "Measurement" });
                        }
                    }
                }
            }

            isPanning = false;
            activeInteraction = { type: null };
            canvas.style.cursor = zoomModeEnabled ? 'zoom-in' : 'grab';
            draw();
        });
        
        canvas.addEventListener('dblclick', (e) => {
            const state = getActiveState();
            if (!state) return;
            const interaction = getInteractionAtPos({ x: e.offsetX, y: e.offsetY }, state);
            if (interaction.type === 'textAnnotation') {
                editTextAnnotation(interaction.index, 'text');
            } else if (interaction.type === 'pointAnnotation') {
                editTextAnnotation(interaction.index, 'point');
            } else if (interaction.type === 'annotation') {
                editTextAnnotation(interaction.index, 'measure');
            } else {
                fullResetView();
            }
        });
        
        function getChannelFromMousePosition(pos, state) {
            if (!state) return null;
            const { x: mouseX, y: mouseY } = pos;
            const { width, height } = canvas.getBoundingClientRect();
            const visibleChannels = getVisibleChannels(state);
            
            if (displayOptions.separateView && !state.isOverlap) {
                if (mouseY < PADDING_STATIC.top || mouseY > height - PADDING_STATIC.bottom || visibleChannels.length === 0) return null;
                const PADDING = getDynamicPadding(state);
                const totalPlotHeight = height - PADDING.top - PADDING.bottom;
                const totalGapHeight = (visibleChannels.length > 1) ? (visibleChannels.length - 1) * SEPARATE_VIEW_GAP : 0;
                const individualPlotHeight = (totalPlotHeight - totalGapHeight) / visibleChannels.length;
                if (individualPlotHeight <= 0) return null;

                const blockHeight = individualPlotHeight + SEPARATE_VIEW_GAP;
                const relativeY = mouseY - PADDING.top;
                
                if (relativeY > 0 && (relativeY % blockHeight) > individualPlotHeight) return null;

                const blockIndex = Math.floor(relativeY / blockHeight);
                if (blockIndex >= 0 && blockIndex < visibleChannels.length) {
                    return visibleChannels[blockIndex];
                }
            } else {
                const PADDING = getDynamicPadding(state);
                if (mouseX >= PADDING.left) return null;
                const index = Math.floor((PADDING.left - 10 - mouseX) / Y_AXIS_WIDTH);
                if (index >= 0 && index < visibleChannels.length) {
                    return visibleChannels[index];
                }
            }
            return null;
        }

    canvas.addEventListener('wheel', e => {
            const state = getActiveState(); if (!state) return;
            e.preventDefault();
            
            const hoveredChannel = getChannelFromMousePosition({ x: e.offsetX, y: e.offsetY }, state);
            
            if (hoveredChannel) { // Y-Axis Zoom
                const chInfo = state.channelInfo[hoveredChannel];
                let plotArea, mouseYRatio;

                if (displayOptions.separateView && !state.isOverlap) {
                    const visibleChannels = getVisibleChannels(state);
                    const chIndex = visibleChannels.indexOf(hoveredChannel);
                    if (chIndex === -1) return;
                    const { width, height } = canvas.getBoundingClientRect();
                    const PADDING = getDynamicPadding(state);
                    const totalPlotHeight = height - PADDING.top - PADDING.bottom;
                    const totalGapHeight = (visibleChannels.length > 1) ? (visibleChannels.length - 1) * SEPARATE_VIEW_GAP : 0;
                    const individualPlotHeight = (totalPlotHeight - totalGapHeight) / visibleChannels.length;
                    if (individualPlotHeight <= 0) return;
                    plotArea = {
                        x: PADDING.left,
                        y: PADDING.top + chIndex * (individualPlotHeight + SEPARATE_VIEW_GAP),
                        width: width - PADDING.left - PADDING.right,
                        height: individualPlotHeight
                    };
                    mouseYRatio = Math.max(0, Math.min(1, (e.offsetY - plotArea.y) / plotArea.height));
                } else {
                    plotArea = getPlotArea(canvas.clientWidth, canvas.clientHeight, state);
                    mouseYRatio = Math.max(0, Math.min(1, (e.offsetY - plotArea.y) / plotArea.height));
                }

                const pivotV = chInfo.vMax - (chInfo.vMax - chInfo.vMin) * mouseYRatio;
                let newVSpan;

                if (displayOptions.discreteZoom) {
                    const yDivs = (displayOptions.separateView && !state.isOverlap) ? Y_DIVS_SEPARATE : Y_DIVS;
                    const vScale = (chInfo.vMax - chInfo.vMin) / yDivs;
                    const newSnappedVScale = getNextSnapScale(vScale, e.deltaY);
                    newVSpan = newSnappedVScale * yDivs;
                } else {
                    const z = e.deltaY < 0 ? 0.85 : 1.15;
                    newVSpan = (chInfo.vMax - chInfo.vMin) * z;
                }
                
                chInfo.vMin = pivotV - newVSpan * (1 - mouseYRatio);
                chInfo.vMax = pivotV + newVSpan * mouseYRatio;

            } else { // X-Axis Zoom/Pan
                if (e.shiftKey) { // Pan
                    const p = (state.view.endIndex - state.view.startIndex) * 0.1 * Math.sign(e.deltaY);
                    state.view.startIndex += p; 
                    state.view.endIndex += p;
                } else { // Zoom
                    const plotArea = getPlotArea(canvas.clientWidth, canvas.clientHeight, state);
                    let mouseXRatio = (e.offsetX - plotArea.x) / plotArea.width;
                    mouseXRatio = Math.max(0, Math.min(1, mouseXRatio));
                    const pivotT = state.view.startIndex + (state.view.endIndex - state.view.startIndex) * mouseXRatio;
                    
                    let newIndexRange;
                    if (displayOptions.discreteZoom) {
                        const timeScale = ((state.view.endIndex - state.view.startIndex) * state.metadata.timePerPoint) / X_DIVS;
                        const snappedTimeScale = getNextSnapScale(timeScale, e.deltaY);
                        newIndexRange = (snappedTimeScale * X_DIVS) / state.metadata.timePerPoint;
                    } else {
                        const z = e.deltaY < 0 ? 0.85 : 1.15;
                        newIndexRange = (state.view.endIndex - state.view.startIndex) * z;
                    }
                    
                    state.view.startIndex = pivotT - newIndexRange * mouseXRatio;
                    state.view.endIndex = pivotT + newIndexRange * (1 - mouseXRatio);
                }
            }

            state.view.startIndex = Math.max(0, state.view.startIndex);
            state.view.endIndex = Math.min(state.metadata.numPoints, state.view.endIndex);
            if (state.view.endIndex - state.view.startIndex < 10) { 
                state.view.endIndex = state.view.startIndex + 10; 
            }
            
            updateControlsFromView(state);
            draw();
        }, { passive: false });
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => document.body.addEventListener(eventName, e => e.preventDefault()));
        ['dragenter', 'dragover'].forEach(eventName => document.body.addEventListener(eventName, () => { if (!isDraggingFile) { dragOverlay.style.display = 'flex'; isDraggingFile = true; } }));
        document.body.addEventListener('dragleave', (e) => { if (e.relatedTarget === null) { dragOverlay.style.display = 'none'; isDraggingFile = false; }});
        document.body.addEventListener('drop', e => { dragOverlay.style.display = 'none'; isDraggingFile = false; for (const file of e.dataTransfer.files) { loadFile(file); } });
        
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('resetViewBtn').addEventListener('click', fullResetView);
        document.getElementById('swapOrderBtn').addEventListener('click', () => { const s=getActiveState(); if (!s) return; s.drawOrder.reverse(); setupChannelUI(s); draw(); });
        document.getElementById('showStatsCheckbox').addEventListener('change', e => { displayOptions.showStats = e.target.checked; document.getElementById('measurement-controls').style.display = e.target.checked ? 'block' : 'none'; draw(); });
        document.querySelectorAll('.meas-toggle').forEach(cb => cb.addEventListener('change', draw));
        document.getElementById('discreteZoomCheckbox').addEventListener('change', e => { displayOptions.discreteZoom = e.target.checked; });
        document.getElementById('relativeTimeCheckbox').addEventListener('change', e => { displayOptions.relativeTime = e.target.checked; draw(); });
        document.getElementById('separateViewCheckbox').addEventListener('change', e => { displayOptions.separateView = e.target.checked; resizeCanvas(); });
        document.getElementById('createOverlapBtn').addEventListener('click', createOverlapTab);
        
        document.getElementById('timeScale').addEventListener('change', e => { 
            const state = getActiveState(); if (!state) return; 
            let newTimeScalePerDiv = parseEng(e.target.value); 
            if (displayOptions.discreteZoom) {
                newTimeScalePerDiv = snapToCommonScale(newTimeScalePerDiv);
            }
            if (isNaN(newTimeScalePerDiv) || newTimeScalePerDiv <= 0) { updateControlsFromView(state); return; } 
            const newTimeSpan = newTimeScalePerDiv * X_DIVS; 
            const newIndexRange = newTimeSpan / state.metadata.timePerPoint; 
            const currentCenterIndex = (state.view.startIndex + state.view.endIndex) / 2; 
            state.view.startIndex = Math.max(0, currentCenterIndex - newIndexRange / 2); 
            state.view.endIndex = Math.min(state.metadata.numPoints, currentCenterIndex + newIndexRange / 2); 
            draw(); 
            updateControlsFromView(state); 
        });

        document.getElementById('cursorBtn').addEventListener('click', () => { const s=getActiveState(); if(!s) return; s.cursors.enabled = !s.cursors.enabled; document.getElementById('cursorBtn').classList.toggle('active'); document.getElementById('cursorPanel').style.display = s.cursors.enabled ? 'block' : 'none'; if (s.cursors.enabled && s.cursors.x1 === null) { const spanT = (s.view.endIndex - s.view.startIndex) * s.metadata.timePerPoint; const startTime = s.view.startIndex * s.metadata.timePerPoint; const firstCh = getVisibleChannels(s)[0]; if(firstCh){const chInfo=s.channelInfo[firstCh]; const spanV=chInfo.vMax-chInfo.vMin; s.cursors.y1=chInfo.vMin+spanV*0.25; s.cursors.y2=chInfo.vMin+spanV*0.75;} s.cursors.x1=startTime+spanT*0.25; s.cursors.x2=startTime+spanT*0.75; trackCursors();} draw(); });
        document.getElementById('clearAnnotationsBtn').addEventListener('click', () => { const s=getActiveState(); if(!s) return; s.annotations = []; s.textAnnotations = []; s.pointAnnotations = []; activeInteraction = {type: null}; draw(); });
        
        // --- ANNOTATION BUTTONS & KEYDOWN ---
        function updateAnnotationButtonState() {
            const state = getActiveState();
            const anyModeActive = state ? (state.annotationMode || textAnnotationMode || pointAnnotationMode) : false;
            document.getElementById('annotateBtn').classList.toggle('active', anyModeActive);
            document.getElementById('clearAnnotationsBtn').style.display = anyModeActive ? 'flex' : 'none';
        }

        document.getElementById('annotateBtn').addEventListener('click', (e) => {
            const s = getActiveState(); if(!s) return;
            s.annotationMode = !s.annotationMode;
            if (s.annotationMode) {
                textAnnotationMode = false;
                pointAnnotationMode = false;
                canvas.style.cursor = 'crosshair';
            } else {
                 canvas.style.cursor = 'grab';
            }
            updateAnnotationButtonState();
        });

        function toggleTextAnnotationMode() {
            const s = getActiveState(); if(!s) return;
            textAnnotationMode = !textAnnotationMode;
            if (textAnnotationMode) {
                s.annotationMode = false;
                pointAnnotationMode = false;
            }
            canvas.style.cursor = textAnnotationMode ? 'text' : 'grab';
            updateAnnotationButtonState();
        }

        function togglePointAnnotationMode() {
            const s = getActiveState(); if(!s) return;
            pointAnnotationMode = !pointAnnotationMode;
            if (pointAnnotationMode) {
                s.annotationMode = false;
                textAnnotationMode = false;
            }
            canvas.style.cursor = pointAnnotationMode ? 'crosshair' : 'grab';
            updateAnnotationButtonState();
        }

        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT') return;
            const state = getActiveState();
            if (e.key.toLowerCase() === 'f') {
                if (state) {
                    const hoveredChannel = getChannelFromMousePosition(lastMousePos, state);
                    if (hoveredChannel) {
                        fitYToChannel(hoveredChannel);
                    } else if (!displayOptions.separateView || state.isOverlap) {
                        fitYToAllVisible();
                    }
                }
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'c') { e.preventDefault(); exportToClipboard(); }
            if (e.ctrlKey && e.key.toLowerCase() === 'h') {
                e.preventDefault();
                if (state) {
                    state.annotationsVisible = !state.annotationsVisible;
                    draw();
                }
            }
            
            const num = parseInt(e.key);
            if (state && !e.ctrlKey && !e.altKey && !isNaN(num) && num >= 1 && num <= 9) {
                if (num - 1 < state.drawOrder.length) {
                    const targetChannelId = state.drawOrder[num - 1];
                    setAnnotationChannel(targetChannelId);
                    e.preventDefault();
                }
            }

            if (e.key === 'Delete' && activeInteraction.type && activeInteraction.index > -1) { if(!state) return; if (activeInteraction.type === 'annotation') { state.annotations.splice(activeInteraction.index, 1); } else if (activeInteraction.type === 'textAnnotation') { state.textAnnotations.splice(activeInteraction.index, 1); } else if (activeInteraction.type === 'pointAnnotation') { state.pointAnnotations.splice(activeInteraction.index, 1); } activeInteraction = {type: null}; draw(); }
            if (e.key.toLowerCase() === 't') { toggleTextAnnotationMode(); }
            if (e.key.toLowerCase() === 'p') { togglePointAnnotationMode(); }
            if (e.key.toLowerCase() === 'z') { if (state && !textAnnotationMode) { zoomModeEnabled = true; canvas.style.cursor = 'zoom-in'; statusText.textContent = 'Zoom Mode: Click and drag on the chart to zoom into an area.'; } }
            if (e.key === 'Escape') {
                if (textAnnotationMode) toggleTextAnnotationMode();
                if (pointAnnotationMode) togglePointAnnotationMode();
                if (zoomModeEnabled) {
                    zoomModeEnabled = false; canvas.style.cursor = 'grab';
                    if (state) statusText.textContent = `Loaded: ${state.fileName}`; else statusText.textContent = 'Ready to load file';
                }
            }
        });
        
        document.getElementById('setToViewMaxBtn').addEventListener('click', () => setCursorsToExtrema('max'));
        document.getElementById('setToViewMinBtn').addEventListener('click', () => setCursorsToExtrema('min'));
        function trackCursors() { const s = getActiveState(); if (!s || !s.cursors.trackingChannel || !s.waveforms[s.cursors.trackingChannel]) return; const data = s.waveforms[s.cursors.trackingChannel]; const i1 = Math.round(s.cursors.x1 / s.metadata.timePerPoint); if(data[i1] !== undefined) s.cursors.y1 = data[i1]; const i2 = Math.round(s.cursors.x2 / s.metadata.timePerPoint); if(data[i2] !== undefined) s.cursors.y2 = data[i2]; }
        function findViewExtrema(channels) { const s = getActiveState(); if (!s) return null; let viewMin = { val: Infinity, time: -1, ch: null }, viewMax = { val: -Infinity, time: -1, ch: null }; const start = Math.floor(s.view.startIndex), end = Math.ceil(s.view.endIndex); channels.forEach(ch => { const data = s.waveforms[ch]; for (let i = start; i < end; i++) { const val = data[i]; if (val < viewMin.val) { viewMin = { val, time: i * s.metadata.timePerPoint, ch }; } if (val > viewMax.val) { viewMax = { val, time: i * s.metadata.timePerPoint, ch }; } } }); return { min: viewMin, max: viewMax }; }
        function setCursorsToExtrema(type) { const s = getActiveState(); if (!s) return; const visibleChannels = getVisibleChannels(s); if (visibleChannels.length === 0) return; const extrema = findViewExtrema(visibleChannels); if(type === 'max' && extrema.max.time !== -1) { s.cursors.x1 = extrema.max.time; s.cursors.y1 = extrema.max.val; } else if (type === 'min' && extrema.min.time !== -1) { s.cursors.x2 = extrema.min.time; s.cursors.y2 = extrema.min.val; } updateCursorReadouts(s); draw(); }
        
        function createTextAnnotationInput(e) { let existingInput = document.getElementById('text-annotation-input'); if(existingInput) existingInput.remove(); const s = getActiveState(); const { time, voltage } = screenToData({x: e.offsetX, y: e.offsetY}, s.view, s); const input = document.createElement('input'); input.type = 'text'; input.id = 'text-annotation-input'; input.style.left = `${e.clientX}px`; input.style.top = `${e.clientY}px`; document.body.appendChild(input); input.focus(); input.addEventListener('keydown', (ev) => { if(ev.key === 'Enter') { if(input.value) { s.textAnnotations.push({ time, voltage, text: input.value, channel: s.annotationChannel }); } input.remove(); toggleTextAnnotationMode(); draw(); } else if (ev.key === 'Escape') { input.remove(); toggleTextAnnotationMode(); } }); }
        function createPointAnnotation(e) {
            const state = getActiveState();
            const mousePos = { x: e.offsetX, y: e.offsetY };
            const targetChannel = hitTestWaveform(mousePos, state);
            if (targetChannel) {
                const plotArea = getPlotArea(canvas.clientWidth, canvas.clientHeight, state);
                const { time } = screenToData(mousePos, state.view, state, targetChannel, plotArea);
                const dataTimePerPoint = state.channelInfo[targetChannel].originalMetadata?.timePerPoint || state.metadata.timePerPoint;
                const index = Math.round(time / dataTimePerPoint);
                const voltage = state.waveforms[targetChannel][index];
                const preciseTime = index * dataTimePerPoint;

                state.pointAnnotations.push({
                    time: preciseTime, voltage: voltage, channel: targetChannel,
                    text: `(${formatEng(preciseTime, '', 3, false)}, ${formatEng(voltage, '', 3, false)})`,
                    textPos: { dx: 15, dy: -15 },
                });
                togglePointAnnotationMode();
                draw();
            }
        }
        function editTextAnnotation(index, type) {
            const state = getActiveState();
            let ann, collection, annChannel, screenPos;
            if (type === 'text') { collection = state.textAnnotations; } 
            else if (type === 'point') { collection = state.pointAnnotations; }
            else if (type === 'measure') { collection = state.annotations; }
            ann = collection[index];
            if (!ann) return;
            annChannel = ann.channel || getVisibleChannels(state)[0];
            if (!annChannel) return;

            let existingInput = document.getElementById('text-annotation-input');
            if(existingInput) existingInput.remove();

            if (type === 'measure') {
                 const p1 = dataToScreen({time: ann.t1, voltage: ann.v1}, state.view, state, annChannel);
                 const p2 = dataToScreen({time: ann.t2, voltage: ann.v2}, state.view, state, annChannel);
                 screenPos = { x: Math.min(p1.x, p2.x), y: Math.min(p1.y, p2.y)};
            } else {
                 screenPos = dataToScreen({time: ann.time, voltage: ann.voltage}, state.view, state, annChannel);
            }
            
            const input = document.createElement('input');
            input.type = 'text'; input.id = 'text-annotation-input'; input.value = ann.text;
            document.body.appendChild(input);

            if (type === 'point') {
                 input.style.left = `${canvas.getBoundingClientRect().left + screenPos.x + ann.textPos.dx}px`;
                 input.style.top = `${canvas.getBoundingClientRect().top + screenPos.y + ann.textPos.dy - 11}px`;
            } else if (type === 'measure') {
                input.style.left = `${canvas.getBoundingClientRect().left + screenPos.x}px`;
                input.style.top = `${canvas.getBoundingClientRect().top + screenPos.y - 22}px`;
            } else {
                 input.style.left = `${canvas.getBoundingClientRect().left + screenPos.x}px`;
                 input.style.top = `${canvas.getBoundingClientRect().top + screenPos.y - 18}px`;
            }
            
            input.focus(); input.select();
            const finalize = () => {
                ann.text = input.value.trim();
                if (!ann.text && type !== 'measure') { collection.splice(index, 1); }
                input.remove(); activeInteraction = {type: null}; draw();
            };
            input.addEventListener('blur', finalize);
            input.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') input.blur(); });
        }
        
        function setAnnotationChannel(chId) {
            const state = getActiveState();
            if (state && state.channelInfo[chId]) {
                state.annotationChannel = chId;
                updateAnnotationChannelUI(state);
            }
        }

        function updateAnnotationChannelUI(state) {
            if (!state || !state.annotationChannel || !state.channelInfo[state.annotationChannel]) return;
            const buttons = document.querySelectorAll('#annotationChannelSelector .tool-button');
            buttons.forEach(btn => {
                const isActive = btn.dataset.channel === state.annotationChannel;
                const chInfo = state.channelInfo[btn.dataset.channel];
                if (chInfo) {
                    btn.style.background = isActive ? chInfo.color : '#5e5e5e';
                    btn.style.opacity = isActive ? '1' : '0.6';
                }
            });
        }
        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; } 
            else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
            return `rgba(${+r},${+g},${+b},${alpha})`;
        }

        function createOverlapTab() {
            destroyOverlapTab(); 
            const sourceTabs = tabStates.filter(s => !s.isOverlap);
            if (sourceTabs.length < 1) return;
            const baseMetadata = { ...sourceTabs[0].metadata };
            let maxTotalTime = 0;
            sourceTabs.forEach(s => { if (s.metadata.totalTime > maxTotalTime) maxTotalTime = s.metadata.totalTime; });
            const mergedState = {
                fileName: "Overlap", isOverlap: true, parser: null, waveforms: {},
                metadata: { ...baseMetadata, numPoints: maxTotalTime / baseMetadata.timePerPoint, totalTime: maxTotalTime },
                channelInfo: {}, drawOrder: [],
                view: { startIndex: 0, endIndex: Math.ceil(maxTotalTime / baseMetadata.timePerPoint) },
                cursors: { enabled: false, x1: null, x2: null, y1: null, y2: null, trackingChannel: null },
                annotations: [], textAnnotations: [], pointAnnotations: [], annotationMode: false, annotationsVisible: true,
            };
            let colorIndex = 0;
            sourceTabs.forEach(sourceState => {
                getVisibleChannels(sourceState).forEach(chId => {
                    const newChId = `${sourceState.fileName}_${chId}`;
                    const sourceChInfo = sourceState.channelInfo[chId];
                    mergedState.waveforms[newChId] = sourceState.waveforms[chId];
                    mergedState.channelInfo[newChId] = {
                        ...sourceChInfo,
                        name: `${sourceState.fileName.replace(/\.(wfm|csv)$/i, '')} - ${sourceChInfo.name}`,
                        color: OVERLAP_COLORS[colorIndex % OVERLAP_COLORS.length],
                        originalMetadata: sourceState.metadata,
                    };
                    mergedState.drawOrder.push(newChId);
                    colorIndex++;
                });
            });
            if (mergedState.drawOrder.length === 0) return;
            if (mergedState.drawOrder.length > 0) mergedState.annotationChannel = mergedState.drawOrder[0];
            const newIndex = tabStates.length;
            tabStates.push(mergedState);
            addTabToUI(mergedState.fileName, newIndex);
            switchToTab(newIndex);
        }

        function destroyOverlapTab() {
            const overlapTabIndex = tabStates.findIndex(s => s.isOverlap);
            if (overlapTabIndex > -1) {
                closeTab(overlapTabIndex);
            }
        }

         function setupModals() {
             const aboutModal=document.getElementById('aboutModal'), exportModal=document.getElementById('exportModal'); 
             document.getElementById('aboutBtn').addEventListener('click', () => { 
                 const date = new Date();
                 const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                 document.getElementById('aboutDate').textContent = `Current Time: ${date.toLocaleDateString('en-SG', options)}`; 
                 aboutModal.style.display='flex'; 
             });
             document.getElementById('exportBtn').addEventListener('click', () => { if(getActiveState()) exportModal.style.display='flex'; });
             [aboutModal, exportModal, csvOptionsModal, pastedDataOptionsModal, document.getElementById('pasteDestinationModal')].forEach(m => { 
                 if (m) {
                     const closeBtn = m.querySelector('.modal-close');
                     const cancelBtn = m.querySelector('.modal-cancel-btn');
                     if (closeBtn) closeBtn.addEventListener('click',()=>m.style.display='none');
                     if (cancelBtn) cancelBtn.addEventListener('click', ()=>m.style.display='none');
                     m.addEventListener('click', e => { if(e.target===m)m.style.display='none'; });
                 }
             });
             document.getElementById('exportConfirmBtn').addEventListener('click', () => { 
                 const options = { content: document.querySelector('input[name="content"]:checked').value, format: document.querySelector('input[name="format"]:checked').value, isIEEE: document.getElementById('ieeeStyleCheckbox').checked, isWB: document.getElementById('wbExportCheckbox').checked, tableAtBottom: document.getElementById('exportTableBottomCheckbox').checked, ieeeWidth: parseFloat(document.getElementById('ieeeWidth').value), ieeeHeight: parseFloat(document.getElementById('ieeeHeight').value), exportStats: document.getElementById('exportStatsCheckbox').checked, exportCursors: document.getElementById('exportCursorsCheckbox').checked, exportAnnotations: document.getElementById('exportAnnotationsCheckbox').checked, }; 
                 executeExport(options); exportModal.style.display = 'none'; 
             });
        }
        async function exportToClipboard() {
             const state = getActiveState(); if (!state) return;
             const isWB = document.getElementById('wbCopyCheckbox').checked;
             try {
                 const blob = await generateImageBlob({ content: 'current', format: 'png', isIEEE: false, isWB: isWB, exportStats: true, exportCursors: state.cursors.enabled, exportAnnotations: true });
                 await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]);
                 statusText.textContent = 'Copied to clipboard!';
                 setTimeout(() => { if (getActiveState()) statusText.textContent = `Loaded: ${getActiveState().fileName}`; }, 2000);
             } catch (err) { statusText.textContent = 'Error: Failed to copy to clipboard.'; console.error(err); }
        }
        /**
 * Main export router. This function is called when the user clicks "Export".
 * It checks the selected options and calls the appropriate generation function.
 */
async function executeExport(options) {
    const state = getActiveState();
    if (!state) return;
    const originalFilename = state.fileName.replace(/\.[^/.]+$/, "");

    // If IEEE style is checked, automatically set format to SVG and ensure a white background.
    if (options.isIEEE) {
        options.format = 'svg';
        options.isWB = true;
    }

    const newFilename = `${originalFilename}_${options.isIEEE ? 'IEEE' : 'export'}.${options.format}`;

    try {
        if (options.format === 'csv') {
            generateAndDownloadCSV(options);
        } else if (options.format === 'svg') {
            // This single function now handles both simple and IEEE-styled SVG exports.
            const svgString = generateExportSVG(options);
            const blob = new Blob([svgString], {
                type: 'image/svg+xml;charset=utf-8'
            });
            downloadBlob(blob, newFilename);
        } else { // PNG export
            const blob = await generateImageBlob(options);
            downloadBlob(blob, newFilename);
        }
    } catch (err) {
        console.error('Export failed:', err);
        statusText.textContent = 'Error during export.';
    }
}


        function downloadBlob(blob, filename) {
             const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename;
             document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function generateImageBlob(options) {
             return new Promise((resolve, reject) => {
                  const state = getActiveState(); if (!state) return reject('No active state');
                  const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d'); const dpr = 2;
                  const w = canvas.clientWidth, h = canvas.clientHeight;
                  tempCanvas.width = w * dpr; tempCanvas.height = h * dpr;
                  tempCtx.scale(dpr, dpr);

                  const { isWB, isIEEE } = options;
                  const colors = {
                    bg: isWB || isIEEE ? '#FFFFFF' : '#1e1e1e',
                    grid: isWB || isIEEE ? '#CCCCCC' : '#333',
                    text: isWB || isIEEE ? '#000000' : '#a0a0a0',
                    axisBorder: isWB || isIEEE ? '#000000' : '#888',
                    cursorTime: isWB || isIEEE ? '#555555' : '#f0ad4e',
                    cursorVolt: isWB || isIEEE ? '#888888' : '#32f0ad',
                    selection: '#00bcf2',
                    statsBg: isWB || isIEEE ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
                    bwTraces: ['#000000', '#0000FF', '#FF0000', '#008000', '#A020F0', '#FFA500']
                  };
                  
                  const tempState = JSON.parse(JSON.stringify(state));
                  Object.keys(state.waveforms).forEach(chId => { tempState.waveforms[chId] = state.waveforms[chId]; });
                  const targetView = options.content === 'all' ? {startIndex: 0, endIndex: tempState.metadata.numPoints } : tempState.view;
                  tempState.view = targetView;
                  
                  drawToContext(tempCtx, tempState, colors);
                  
                  tempCanvas.toBlob(blob => { if (blob) resolve(blob); else reject('Canvas to Blob conversion failed'); }, 'image/png');
                 });
        }
        
        function generateAndDownloadCSV(options) {
           const state = getActiveState();
           if (!state) { alert("No active waveform to export."); return; }
           const visibleChannels = getVisibleChannels(state);
           if (visibleChannels.length === 0) { alert("No visible channels to export."); return; }
           const startIndex = options.content === 'current' ? Math.floor(state.view.startIndex) : 0;
           const endIndex = options.content === 'current' ? Math.ceil(state.view.endIndex) : state.metadata.numPoints;
           const timeStep = state.metadata.timePerPoint;
           const headers = ['"Time (s)"'];
           visibleChannels.forEach(chId => {
               const chInfo = state.channelInfo[chId];
               headers.push(`"${chInfo.name} (${chInfo.units})"`);
           });
           let csvString = headers.join(',') + '\r\n';
           for (let i = startIndex; i < endIndex; i++) {
               if (i >= 0 && i < state.metadata.numPoints) {
                   const rowData = [(i * timeStep).toExponential(6)];
                   visibleChannels.forEach(chId => {
                       const val = state.waveforms[chId][i];
                       rowData.push(val !== undefined ? val.toExponential(6) : '');
                   });
                   csvString += rowData.join(',') + '\r\n';
               }
           }
           const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
           const originalFilename = state.fileName.replace(/\.[^/.]+$/, "");
           const newFilename = `${originalFilename}_${options.content}.csv`;
           downloadBlob(blob, newFilename);
        }

        // SEPARATE EXPORT FUNCTION for SVG
/**
 * Generates an SVG string from the current waveform view based on export options.
 * @param {object} options - The export settings from the modal.
 * @returns {string} The complete SVG content as a string.
 */
function generateExportSVG(options) {
    const state = getActiveState();
    if (!state) return '';

    const isIEEE = options.isIEEE;
    const DPI = 96; // Standard pixels per inch for sizing.
    const figWidth = isIEEE ? 3.5 * DPI : canvas.clientWidth;
    const figHeight = isIEEE ? 3.0 * DPI : canvas.clientHeight;

    // Define styles based on whether it's a simple or IEEE export.
    const styles = {
        fontFamily: isIEEE ? "'Times New Roman', Times, serif" : "'Segoe UI', system-ui, sans-serif",
        fontSize: isIEEE ? '10pt' : '13px',
        bgColor: options.isWB || isIEEE ? '#ffffff' : '#1e1e1e',
        fgColor: options.isWB || isIEEE ? '#000000' : '#a0a0a0',
        gridColor: isIEEE ? 'none' : (options.isWB ? '#cccccc' : '#333'),
        // For IEEE, use distinct line styles for black & white printing.
        traceStyles: [
            { stroke: '#000000', 'stroke-dasharray': 'none' }, // Solid
            { stroke: '#000000', 'stroke-dasharray': '5 5' },   // Dashed
            { stroke: '#555555', 'stroke-dasharray': '2 4' },   // Dotted
            { stroke: '#555555', 'stroke-dasharray': '8 4 2 4' } // Dash-dot
        ]
    };

    // Use a temporary copy of the state for manipulation.
    const tempState = JSON.parse(JSON.stringify(state));
    Object.keys(state.waveforms).forEach(chId => { tempState.waveforms[chId] = state.waveforms[chId]; });
    const view = options.content === 'all' ? {startIndex: 0, endIndex: tempState.metadata.numPoints } : tempState.view;

    let svg = `<svg width="${figWidth}" height="${figHeight}" xmlns="http://www.w3.org/2000/svg" style="font-family: ${styles.fontFamily}; font-size: ${styles.fontSize};">`;
    svg += `<rect x="0" y="0" width="${figWidth}" height="${figHeight}" fill="${styles.bgColor}" />`;

    // Calculate the plot area with padding for axes and titles.
    const PADDING = { top: 25, right: 20, bottom: 45, left: 60 };
    const plotArea = {
        x: PADDING.left,
        y: PADDING.top,
        width: figWidth - PADDING.left - PADDING.right,
        height: figHeight - PADDING.top - PADDING.bottom
    };

    // Helper to convert data points to SVG coordinates.
    const dataToSvg = (dataPos, chId) => {
        const chInfo = tempState.channelInfo[chId];
        const viewTimeSpan = (view.endIndex - view.startIndex) * tempState.metadata.timePerPoint;
        const viewVoltSpan = chInfo.vMax - chInfo.vMin;
        if (viewTimeSpan <= 0 || viewVoltSpan <= 0) return {x: 0, y: 0};
        
        const timeOffset = tempState.metadata.timeStart || 0;
        const viewStartTime = (view.startIndex * tempState.metadata.timePerPoint);

        const x = plotArea.x + ((dataPos.time - timeOffset - viewStartTime) / viewTimeSpan) * plotArea.width;
        const y = plotArea.y + ((chInfo.vMax - dataPos.voltage) / viewVoltSpan) * plotArea.height;
        return { x, y };
    };

    // Draw grid lines if not in IEEE mode.
    if (styles.gridColor !== 'none') {
        let gridLines = '';
        for (let i = 0; i <= X_DIVS; i++) {
            const x = plotArea.x + i / X_DIVS * plotArea.width;
            gridLines += `<line x1="${x}" y1="${plotArea.y}" x2="${x}" y2="${plotArea.y + plotArea.height}" stroke="${styles.gridColor}" stroke-width="0.5" />`;
        }
        for (let i = 0; i <= Y_DIVS; i++) {
            const y = plotArea.y + i / Y_DIVS * plotArea.height;
            gridLines += `<line x1="${plotArea.x}" y1="${y}" x2="${plotArea.x + plotArea.width}" y2="${y}" stroke="${styles.gridColor}" stroke-width="0.5" />`;
        }
        svg += `<g id="grid">${gridLines}</g>`;
    }

    // Draw axes, ticks, and titles.
    svg += `<g id="axes" fill="${styles.fgColor}" stroke="${styles.fgColor}" stroke-width="1">`;
    svg += `<rect x="${plotArea.x}" y="${plotArea.y}" width="${plotArea.width}" height="${plotArea.height}" fill="none" />`;

    const visibleChannels = getVisibleChannels(tempState);
    if(visibleChannels.length > 0) {
        const timeSpan = (view.endIndex - view.startIndex) * tempState.metadata.timePerPoint;
        const tStart = (view.startIndex * tempState.metadata.timePerPoint) + (tempState.metadata.timeStart || 0);
        for (let i = 0; i <= X_DIVS; i += 2) {
            const x = plotArea.x + i / X_DIVS * plotArea.width;
            const timeVal = tStart + i / X_DIVS * timeSpan;
            svg += `<text x="${x}" y="${plotArea.y + plotArea.height + 15}" text-anchor="middle" dominant-baseline="hanging">${formatEng(timeVal, 's', 2, false)}</text>`;
        }
        svg += `<text x="${plotArea.x + plotArea.width / 2}" y="${figHeight - 5}" text-anchor="middle" font-weight="normal">Time (s)</text>`;

        const refChId = visibleChannels[0];
        const refChInfo = tempState.channelInfo[refChId];
        const vRange = refChInfo.vMax - refChInfo.vMin;
        for (let j = 0; j <= Y_DIVS; j += 2) {
            const y = plotArea.y + j / Y_DIVS * plotArea.height;
            const v = refChInfo.vMax - j / Y_DIVS * vRange;
            svg += `<text x="${plotArea.x - 8}" y="${y}" text-anchor="end" dominant-baseline="middle">${formatEng(v, '', 2, false)}</text>`;
        }
        const yTitleX = 15;
        const yTitleY = plotArea.y + plotArea.height / 2;
        svg += `<text x="${yTitleX}" y="${yTitleY}" text-anchor="middle" transform="rotate(-90, ${yTitleX}, ${yTitleY})" font-weight="normal">Voltage (${refChInfo.units})</text>`;
    }
    svg += `</g>`;

    // Draw waveforms inside a clipping path.
    svg += `<g id="waveforms" clip-path="url(#clip)">`;
    svg += `<defs><clipPath id="clip"><rect x="${plotArea.x}" y="${plotArea.y}" width="${plotArea.width}" height="${plotArea.height}" /></clipPath></defs>`;
    
    const allPoints = []; 
    visibleChannels.forEach((ch, index) => {
        const voltageData = tempState.waveforms[ch];
        let pathData = '';
        const startIndex = Math.max(0, Math.floor(view.startIndex));
        const endIndex = Math.min(voltageData.length, Math.ceil(view.endIndex));
        
        for (let i = startIndex; i < endIndex; i++) {
            const time = (i * tempState.metadata.timePerPoint);
            const voltage = voltageData[i];
            if (voltage === undefined) continue;
            const p = dataToSvg({ time, voltage }, ch);
            if (isIEEE) allPoints.push(p);
            pathData += (pathData === '' ? 'M' : 'L') + ` ${p.x.toFixed(2)} ${p.y.toFixed(2)} `;
        }
        
        const style = isIEEE 
            ? Object.entries(styles.traceStyles[index % styles.traceStyles.length]).map(([k,v]) => `${k}="${v}"`).join(' ')
            : `stroke="${tempState.channelInfo[ch].color}"`;
            
        svg += `<path d="${pathData}" fill="none" ${style} stroke-width="1.5" />`;
    });
    svg += `</g>`;

    // Draw all annotations, cursors, etc.
    svg += drawAnnotationsSVG(tempState, view, plotArea, dataToSvg, options);
    
    // Draw the legend if in IEEE mode.
    if(isIEEE && visibleChannels.length > 0) {
        const legendWidth = 120;
        const legendHeight = (visibleChannels.length * 15) + 15;
        const legendPadding = 5;
        
        const corners = {
            'top-right': { x: plotArea.x + plotArea.width - legendWidth - legendPadding, y: plotArea.y + legendPadding, overlap: 0 },
            'top-left': { x: plotArea.x + legendPadding, y: plotArea.y + legendPadding, overlap: 0 },
            'bottom-right': { x: plotArea.x + plotArea.width - legendWidth - legendPadding, y: plotArea.y + plotArea.height - legendHeight - legendPadding, overlap: 0 },
            'bottom-left': { x: plotArea.x + legendPadding, y: plotArea.y + plotArea.height - legendHeight - legendPadding, overlap: 0 }
        };

        for (const p of allPoints) {
            for (const key in corners) {
                const c = corners[key];
                if (p.x >= c.x && p.x <= c.x + legendWidth && p.y >= c.y && p.y <= c.y + legendHeight) c.overlap++;
            }
        }

        let bestCornerKey = Object.keys(corners).reduce((a, b) => corners[a].overlap < corners[b].overlap ? a : b);
        const legendPos = corners[bestCornerKey];
        
        svg += `<g id="legend" transform="translate(${legendPos.x}, ${legendPos.y})">`;
        svg += `<rect x="0" y="0" width="${legendWidth}" height="${legendHeight}" fill="${styles.bgColor}" stroke="${styles.fgColor}" stroke-width="0.5" />`;
        visibleChannels.forEach((ch, index) => {
            const chInfo = tempState.channelInfo[ch];
            const yPos = 12 + index * 15;
            const traceStyle = styles.traceStyles[index % styles.traceStyles.length];
            svg += `<line x1="5" y1="${yPos}" x2="25" y2="${yPos}" stroke="${traceStyle.stroke}" stroke-width="1.5" stroke-dasharray="${traceStyle['stroke-dasharray']}" />`;
            svg += `<text x="30" y="${yPos}" dominant-baseline="middle" fill="${styles.fgColor}">${chInfo.name}</text>`;
        });
        svg += `</g>`;
    }

    svg += '</svg>';
    return svg;
}


/**
 * Helper function to generate SVG elements for all annotations, cursors, etc.
 * @returns {string} An SVG <g> element containing all annotation graphics.
 */
function drawAnnotationsSVG(state, view, plotArea, dataToSvgFunc, options) {
    let svg = `<g id="annotations-group">`;
    const isIEEE = options.isIEEE;
    const fgColor = isIEEE ? '#000000' : '#a0a0a0';

    const createText = (x, y, text, color, otherAttrs = '') => `<text x="${x}" y="${y}" fill="${color}" ${otherAttrs}>${text}</text>`;

    if (options.exportAnnotations && state.annotationsVisible) {
        (state.annotations || []).forEach(box => {
            const boxChId = box.channel || getVisibleChannels(state)[0];
            if (!boxChId) return;
            const p1 = dataToSvgFunc({ time: box.t1, voltage: box.v1 }, boxChId);
            const p2 = dataToSvgFunc({ time: box.t2, voltage: box.v2 }, boxChId);
            const color = isIEEE ? '#555555' : state.channelInfo[boxChId].color;
            svg += `<rect x="${Math.min(p1.x,p2.x)}" y="${Math.min(p1.y,p2.y)}" width="${Math.abs(p1.x - p2.x)}" height="${Math.abs(p1.y - p2.y)}" fill="${color}" fill-opacity="0.1" stroke="${color}" stroke-width="1" />`;
            if (box.text) svg += createText(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y) - 5, box.text, color, 'font-size="9pt"');
        });

        (state.textAnnotations || []).forEach(ann => {
             const annChId = ann.channel || getVisibleChannels(state)[0];
             if (!annChId) return;
             const pos = dataToSvgFunc({ time: ann.time, voltage: ann.voltage }, annChId);
             const color = isIEEE ? fgColor : state.channelInfo[annChId].color;
             svg += createText(pos.x, pos.y, ann.text, color);
        });

        (state.pointAnnotations || []).forEach(ann => {
            const pos = dataToSvgFunc({ time: ann.time, voltage: ann.voltage }, ann.channel);
            const color = isIEEE ? fgColor : state.channelInfo[ann.channel].color;
            svg += `<circle cx="${pos.x}" cy="${pos.y}" r="3" fill="${color}" />`;
            const textX = pos.x + ann.textPos.dx, textY = pos.y + ann.textPos.dy;
            svg += `<line x1="${pos.x}" y1="${pos.y}" x2="${textX}" y2="${textY}" stroke="${color}" stroke-width="1" />`;
            svg += createText(textX + 5, textY, ann.text, color, 'dominant-baseline="middle"');
        });
    }

    if(options.exportCursors && state.cursors.enabled) {
        const refCh = getVisibleChannels(state)[0];
        if (refCh) {
            const style = `stroke="${isIEEE ? '#555555' : '#f0ad4e'}" stroke-width="1.5" stroke-dasharray="6 4"`;
            const x1 = dataToSvgFunc({time: state.cursors.x1, voltage: 0}, refCh).x;
            const x2 = dataToSvgFunc({time: state.cursors.x2, voltage: 0}, refCh).x;
            const y1 = dataToSvgFunc({time: 0, voltage: state.cursors.y1}, refCh).y;
            const y2 = dataToSvgFunc({time: 0, voltage: state.cursors.y2}, refCh).y;
            svg += `<line x1="${x1}" y1="${plotArea.y}" x2="${x1}" y2="${plotArea.y + plotArea.height}" ${style} />`;
            svg += `<line x1="${x2}" y1="${plotArea.y}" x2="${x2}" y2="${plotArea.y + plotArea.height}" ${style} />`;
            svg += `<line x1="${plotArea.x}" y1="${y1}" x2="${plotArea.x + plotArea.width}" y2="${y1}" ${style} />`;
            svg += `<line x1="${plotArea.x}" y1="${y2}" x2="${plotArea.x + plotArea.width}" y2="${y2}" ${style} />`;
        }
    }
    
    svg += `</g>`;
    return svg;
}

        // SEPARATE EXPORT FUNCTION for IEEE
        function generateExportIEEE(options) {
            // This would create a new canvas with specific dimensions, fonts, etc.
            // and use drawToContext to render the image.
            alert("IEEE export is not fully implemented yet.");
            return new Promise(resolve => resolve(new Blob()));
        }

        document.getElementById('channelButtonContainer').addEventListener('dblclick', (e) => {
            const nameSpan = e.target.closest('.ch-name');
            if (!nameSpan || channelButtonContainer.querySelector('input')) return;
            
            const state = getActiveState();
            if (!state) return;
            
            const button = nameSpan.closest('.channel-button');
            const chId = button.dataset.channel;
            const originalName = state.channelInfo[chId].name;
            const icon = nameSpan.querySelector('i').cloneNode(true);

            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalName;
            Object.assign(input.style, { 
                width: 'calc(100% - 25px)', 
                backgroundColor: '#333', 
                border: '1px solid #0078d7', 
                color: 'white', 
                padding: '2px', 
                marginLeft: '5px' 
            });

            nameSpan.innerHTML = '';
            nameSpan.appendChild(icon);
            nameSpan.appendChild(input);
            input.focus();
            input.select();

            const finalizeEdit = () => {
                const newName = input.value.trim() || originalName;
                state.channelInfo[chId].name = newName;
                setupChannelUI(state);
                updateChannelScaleControls(state);
            };

            input.addEventListener('blur', finalizeEdit);
            input.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') input.blur();
                else if (ev.key === 'Escape') {
                    input.value = originalName; // Revert
                    input.blur();
                }
            });
        });

        // --- SESSION SAVE/LOAD ---
        document.getElementById('saveSessionBtn').addEventListener('click', saveSession);

        function uint8ArrayToBase64(bytes) {
            let binary = '';
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToUint8Array(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes;
        }

        function saveSession() {
            if (tabStates.length === 0) {
                alert("Nothing to save!");
                return;
            }

            const serializableTabs = tabStates.map(state => {
                const serializableState = { ...state };
                delete serializableState.parser;

                serializableState.waveforms = {};
                for (const chId in state.waveforms) {
                    serializableState.waveforms[chId] = Array.from(state.waveforms[chId]);
                }
                return serializableState;
            });

            const sessionData = {
                version: "1.2.0-compressed",
                savedAt: new Date().toISOString(),
                tabs: serializableTabs
            };

            const jsonString = JSON.stringify(sessionData);
            const compressedData = pako.deflate(jsonString);
            const base64String = uint8ArrayToBase64(compressedData);
            
            const blob = new Blob([base64String], { type: 'text/plain' });
            downloadBlob(blob, `session_${Date.now()}.graphx`);
            statusText.textContent = "Session saved successfully.";
        }

        function loadSession(fileContent) {
            try {
                let jsonString = fileContent;
                
                if (!fileContent.trim().startsWith('{')) {
                    const compressedData = base64ToUint8Array(fileContent);
                    jsonString = pako.inflate(compressedData, { to: 'string' });
                }

                const sessionData = JSON.parse(jsonString);
                if (!sessionData.version || !sessionData.tabs) {
                    throw new Error("Invalid or corrupted session file.");
                }

                tabStates = [];
                activeTabIndex = -1;
                const overlapBtn = document.getElementById('createOverlapBtn');
                tabContainer.innerHTML = '';
                tabContainer.appendChild(overlapBtn);

                sessionData.tabs.forEach((savedTab, index) => {
                    const newState = { ...savedTab };
                    // Add new features to old save files gracefully
                    if(!newState.pointAnnotations) newState.pointAnnotations = [];
                    newState.waveforms = {};
                    for (const chId in savedTab.waveforms) {
                        newState.waveforms[chId] = new Float32Array(savedTab.waveforms[chId]);
                    }
                    tabStates.push(newState);
                    addTabToUI(newState.fileName, index);
                });

                if (tabStates.length > 0) {
                    switchToTab(0);
                } else {
                    updateUIFromState(); // Clear UI if the session was empty
                }
                statusText.textContent = "Session loaded successfully.";
            } catch (err) {
                statusText.textContent = `Error loading session: ${err.message}`;
                console.error(err);
            }
        }

        // --- CSV Modal Logic ---
        function showCsvOptionsModal(csvText, fileName) {
            tempCsvData = { text: csvText, fileName: fileName };
            const lines = csvText.replace(/\r/g, '').split('\n');
            
            let preview = '';
            if (lines.length <= 6) {
                preview = lines.join('\n');
            } else {
                preview = lines.slice(0, 5).join('\n') + '\n...\n' + lines[lines.length - 1];
            }
            document.getElementById('csvPreviewContent').textContent = preview;
            document.getElementById('csvOptionsFileName').textContent = fileName;

            document.getElementById('csvDelimiter').value = ',';
            document.getElementById('csvHasHeader').checked = true;

            updateCsvColumnMapping();
            csvOptionsModal.style.display = 'flex';
        }

        function updateCsvColumnMapping() {
            const delimiter = document.getElementById('csvDelimiter').value || ',';
            const hasHeader = document.getElementById('csvHasHeader').checked;
            const lines = tempCsvData.text.replace(/\r/g, '').split('\n');
            if (lines.length === 0) return;

            const firstLine = lines[0].trim();
            const columns = firstLine.split(delimiter);
            const container = document.getElementById('csvColumnMapping');
            container.innerHTML = '';

            if (columns.length === 1 && firstLine) {
                container.innerHTML = `<div class="control-item"><span>Single column detected. It will be plotted as a channel with point numbers (0, 1, 2...) for the X-axis.</span></div>`;
                return;
            }
            
            columns.forEach((col, index) => {
                let headerName;
                if (hasHeader) {
                    headerName = col.trim().replace(/^"|"$/g, '');
                } else {
                    headerName = (index === 0) ? 'x (time)' : `f(x) ${index}`;
                }
                const row = document.createElement('div');
                row.className = 'control-item';
                row.innerHTML = `
                    <span class="control-label" title="${headerName}" style="color: #eee; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${headerName}</span>
                    <select class="control-input csv-role-select" data-col-index="${index}" style="width: 150px;">
                        <option value="channel">Channel (Y-Axis)</option>
                        <option value="time">Time (X-Axis)</option>
                        <option value="ignore">Ignore</option>
                    </select>
                `;
                container.appendChild(row);
            });

            const selects = container.querySelectorAll('select');
            const timeKeywords = ['time', 't', 'seconds', 's', 'x'];
            let timeColumnFound = false;
            
            columns.forEach((col, index) => {
                const normalizedHeader = col.trim().replace(/^"|"$/g, '').toLowerCase();
                if (!timeColumnFound && timeKeywords.includes(normalizedHeader)) {
                    selects[index].value = 'time';
                    timeColumnFound = true;
                }
            });

            if (!timeColumnFound && selects.length > 0) {
                selects[0].value = 'time';
            }
        }

        document.getElementById('csvDelimiter').addEventListener('input', updateCsvColumnMapping);
        document.getElementById('csvHasHeader').addEventListener('change', updateCsvColumnMapping);

        // --- Paste Logic ---
        let tempPastedText = '';
        let pasteDestination = 'new'; // 'new' or 'current'

        document.body.addEventListener('paste', handlePaste);

        function handlePaste(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            if (!text || text.trim().length === 0) return;

            tempPastedText = text;

            const pasteDestinationModal = document.getElementById('pasteDestinationModal');
            const pasteToCurrentBtn = document.getElementById('pasteToCurrentBtn');

            if (getActiveState()) {
                pasteToCurrentBtn.disabled = false;
                pasteToCurrentBtn.style.opacity = 1;
                pasteToCurrentBtn.style.cursor = 'pointer';

            } else {
                pasteToCurrentBtn.disabled = true;
                pasteToCurrentBtn.style.opacity = 0.5;
                pasteToCurrentBtn.style.cursor = 'not-allowed';
            }
            pasteDestinationModal.style.display = 'flex';
        }
        
        function processPastedText() {
            const lines = tempPastedText.trim().split('\n');
            if (lines.length === 0) return;
            const numRows = lines.length;

            let delimiter = ',';
            if (lines[0].includes('\t')) {
                delimiter = '\t';
            }
            const numCols = lines[0].split(delimiter).length;

            if (numRows > 1 && numCols > 1) {
                showCsvOptionsModal(tempPastedText, "Pasted Data");
            } else {
                // Handle both single row (numRows=1) and single column (numCols=1)
                const values = tempPastedText.trim().split(/[\s,	]+/); // Split by any whitespace, comma, or tab
                const data = values.map(v => parseFloat(v)).filter(n => !isNaN(n));

                if (data.length > 1) {
                    tempPastedData = data;
                    document.getElementById('pasteTimeStart').value = '0';
                    document.getElementById('pasteTimeStep').value = '1';
                    pastedDataOptionsModal.style.display = 'flex';
                } else {
                    alert("Could not find valid numeric data to paste.");
                }
            }
        }

        function mergeDataIntoCurrentTab(parser) {
            const state = getActiveState();
            if (!state) return;

            const channelNames = parser.channelNames || parser.getChannelNames();
            let colorIndex = state.drawOrder.length;

            channelNames.forEach(chName => {
                const data = parser.getChannelData(chName);
                if (data) {
                    let min = Infinity, max = -Infinity;
                    for(const v of data) {
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    const margin = (max - min) * 0.1 || 1;

                    let newChId = chName;
                    let counter = 1;
                    while (state.waveforms[newChId]) {
                        newChId = `${chName}_${counter++}`;
                    }

                    state.waveforms[newChId] = data;
                    state.drawOrder.push(newChId);
                    state.channelInfo[newChId] = {
                        name: newChId,
                        visible: true,
                        color: OVERLAP_COLORS[colorIndex % OVERLAP_COLORS.length],
                        units: parser.getVoltageUnits(newChId),
                        vMin: min - margin,
                        vMax: max + margin,
                    };
                    colorIndex++;
                }
            });

            updateUIFromState();
            fitYToAllVisible();
        }

        const pasteDestinationModal = document.getElementById('pasteDestinationModal');
        document.getElementById('pasteToCurrentBtn').addEventListener('click', () => {
            pasteDestination = 'current';
            pasteDestinationModal.style.display = 'none';
            processPastedText();
        });
        document.getElementById('pasteToNewBtn').addEventListener('click', () => {
            pasteDestination = 'new';
            pasteDestinationModal.style.display = 'none';
            processPastedText();
        });

        document.getElementById('csvOptionsConfirm').addEventListener('click', () => {
            const options = {
                delimiter: document.getElementById('csvDelimiter').value || ',',
                hasHeader: document.getElementById('csvHasHeader').checked,
                timeColumnIndex: -1,
                dataColumnIndices: [],
                autoTime: false,
            };

            const firstLine = tempCsvData.text.split('\n')[0].trim();
            if (firstLine.split(options.delimiter).length === 1 && firstLine) {
                options.autoTime = true;
                options.dataColumnIndices.push(0);
            } else {
                const selects = document.querySelectorAll('.csv-role-select');
                selects.forEach(select => {
                    const colIndex = parseInt(select.dataset.colIndex, 10);
                    if (select.value === 'time') {
                        options.timeColumnIndex = colIndex;
                    } else if (select.value === 'channel') {
                        options.dataColumnIndices.push(colIndex);
                    }
                });

                if (options.timeColumnIndex === -1 && options.dataColumnIndices.length > 0) {
                     options.autoTime = true;
                     options.timeColumnIndex = 0; // dummy, won't be used
                } else if (options.timeColumnIndex === -1) {
                    alert("Please select one column for 'Time (X-Axis)'.");
                    return;
                }
            }
            
            csvOptionsModal.style.display = 'none';
            statusText.textContent = `Processing ${tempCsvData.fileName}...`;

            try {
                const parser = new CsvParser(tempCsvData.text, options);
                if (!parser.isValid()) {
                    throw new Error(parser.error || "Failed to parse CSV file with selected options.");
                }

                if (pasteDestination === 'current' && getActiveState()) {
                    mergeDataIntoCurrentTab(parser);
                    statusText.textContent = `Pasted data added to ${getActiveState().fileName}`;
                } else {
                    const newState = createDefaultTabState(tempCsvData.fileName, parser);
                    const newIndex = tabStates.length;
                    tabStates.push(newState);
                    addTabToUI(tempCsvData.fileName, newIndex);
                    switchToTab(newIndex);
                    statusText.textContent = `Loaded: ${tempCsvData.fileName}`;
                }
            } catch (err) {
                statusText.textContent = `Error processing ${tempCsvData.fileName}: ${err.message}`;
                console.error(err);
            }
        });

        document.getElementById('pasteConfirmBtn').addEventListener('click', () => {
            const start = parseEng(document.getElementById('pasteTimeStart').value);
            const step = parseEng(document.getElementById('pasteTimeStep').value);
            if (isNaN(start) || isNaN(step) || step <= 0) {
                alert("Invalid start or step value.");
                return;
            }
            const parser = new PastedDataParser(tempPastedData, { start, step });

            if (pasteDestination === 'current' && getActiveState()) {
                 mergeDataIntoCurrentTab(parser);
                 statusText.textContent = `Pasted data added to ${getActiveState().fileName}`;
            } else {
                const newState = createDefaultTabState('Pasted Data', parser, { start });
                const newIndex = tabStates.length;
                tabStates.push(newState);
                addTabToUI(newState.fileName, newIndex);
                switchToTab(newIndex);
                statusText.textContent = `Loaded: Pasted Data`;
            }
            pastedDataOptionsModal.style.display = 'none';
        });

        setupModals();
        new ResizeObserver(resizeCanvas).observe(document.getElementById('waveformContainer'));
        draw(); 
    });
</script>
</body>
</html>
